{
  "version": 1,
  "nodes": [
    {
      "id": "demo-webgl",
      "parentId": "folder-demos",
      "name": "WebGL_Demo.md",
      "type": "FILE",
      "content": "# WebGL Demo\n```ide\n{\n  \"js\": \"console.log('Hello World');\"\n}\n```",
      "createdAt": 1768807949929
    },
    {
      "id": "8599598d-70cd-4cd8-96a4-102bf8c681fc",
      "parentId": null,
      "name": "Webgl-shadow",
      "type": "FOLDER",
      "content": "",
      "createdAt": 1768821532574
    },
    {
      "id": "fa8d3bc9-edb8-4bc3-9efd-26a5f176bef2",
      "parentId": "8599598d-70cd-4cd8-96a4-102bf8c681fc",
      "name": "shadow_notes",
      "type": "FILE",
      "content": "# Orthographic 3D\n\n### For 2D : \n\n```c\n#version 300 es\n \n// an attribute is an input (in) to a vertex shader.\n// It will receive data from a buffer\nin vec2 a_position;\n \n// A matrix to transform the positions by\nuniform mat3 u_matrix;\n \n// all shaders have a main function\nvoid main() {\n  // Multiply the position by the matrix.\n  gl_Position = vec4((u_matrix * vec3(a_position, 1)).xy, 0, 1);\n}\n```\n\n### From 2D to 3D:\n\n```c\n// an attribute is an input (in) to a vertex shader.\n// It will receive data from a buffer\nin vec4 a_position;\n \n// A matrix to transform the positions by\nuniform mat4 u_matrix;\n \n// all shaders have a main function\nvoid main() {\n  // Multiply the position by the matrix.\n  gl_Position = u_matrix * a_position;\n}\n```\n\n### Old 2D projection :\n\n```c\n  projection: function (width, height) {\n    // Note: This matrix flips the Y axis so 0 is at the top.\n    return [\n      2 / width, 0, 0,\n      0, -2 / height, 0,\n      -1, 1, 1\n    ];\n  },\n}\n```\n\n### New 3D Project\n> Which convented from pixels to clip space. \n\n```c\n projection: function(width, height, depth) {\n    // Note: This matrix flips the Y axis so 0 is at the top.\n    return [\n       2 / width, 0, 0, 0,\n       0, -2 / height, 0, 0,\n       0, 0, 2 / depth, 0,\n      -1, 1, 0, 1,\n    ];\n  },\n```\n\n# Step 1 - WebGL 3D\n\n```ide\n{\n  \"js\": \"var vertexShaderSource = `#version 300 es\\n\\n// an attribute is an input (in) to a vertex shader.\\n// It will receive data from a buffer\\nin vec4 a_position;\\n\\n// A matrix to transform the positions by\\nuniform mat4 u_matrix;\\n\\nvoid main(){\\n gl_Position = u_matrix * a_position;\\n}\\n`;\\nvar fragmentShaderSource = `#version 300 es\\n\\nprecision highp float;\\nuniform vec4 u_color;\\nout vec4 outColor;\\n\\nvoid main(){\\n outColor = u_color;\\n}\\n`;\\n\\n//create geometry\\nfunction setGeometry(gl){\\n  gl.bufferData(gl.ARRAY_BUFFER,F_2D.positions,gl.STATIC_DRAW);\\n}\\n\\n//var GUI = lil.GUI;\\n\\n\\nfunction main(){\\n\\n\\n  var canvas = document.querySelector(\\\"#canvas\\\");\\n  var gl = canvas.getContext(\\\"webgl2\\\");\\n  if(!gl) return;\\n  \\n  var program = webglUtils.generate(gl, vertexShaderSource, fragmentShaderSource);\\n\\n  //loop up where the vertex data need to go.\\n  var positionAttributeLocation = gl.getAttribLocation(program,\\\"a_position\\\");\\n\\n  //loop up uniform locations\\n  var colorLocation = gl.getUniformLocation(program, \\\"u_color\\\");\\n  var matrixLocation = gl.getUniformLocation(program, \\\"u_matrix\\\");\\n\\n  //create a buffer\\n  var positionBuffer = gl.createBuffer();\\n\\n  //create a vertex array object (attribute state)\\n  var vao = gl.createVertexArray();\\n\\n  //and make it the one we're currently working with\\n  gl.bindVertexArray(vao);\\n  \\n  //turn on the attribute\\n  gl.enableVertexAttribArray(positionAttributeLocation);\\n\\n  //bind it to ARRAY_BUFFER (think of it as ARRAY_BUFFER = positionBuffer)\\n  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\\n\\n  //set geometry\\n  setGeometry(gl);\\n\\n  //tell the attribute how to get data out of positionBuffer (ARRAY_BUFFER)\\n  var size = 3 ;              // 3 components per iteration\\n  var type = gl.FLOAT;        // the data is 32bit floats\\n  var normalize = false;      // don't normalize the data\\n  var stride = 0;             // 0 = move forward size * sizeof(type) each iteration to get the next position\\n  var offset = 0;             // start at the beginning of the buffer\\n\\n  gl.vertexAttribPointer(positionAttributeLocation, size, type, normalize, stride, offset);\\n\\n /*\\n  function deg_to_rad(angle){\\n    return angle * (Math.PI/180.0);\\n  }\\n  \\n  // initial\\n  var translation = {tx:45, ty:150, tz:0};\\n  var rotation = {rx:deg_to_rad(40),ry:deg_to_rad(25),rz:deg_to_rad(325)};\\n  var scaling = {sx:1, sy:1, sz:1};\\n  var colors = {r:Math.random(),g: Math.random(),b: Math.random(), a:1};\\n\\n\\n  var transformationObj = {\\n    'translate':translation,\\n    'rotate':rotation,\\n    'scale':scaling,\\n    'colors':colors \\n  };\\n   \\n\\n  const gui = new GUI();\\n  gui.add(document,'title');\\n \\n  const translate = gui.addFolder('Translate');\\n  const rotate = gui.addFolder('Rotate');\\n  const scale = gui.addFolder('Scale');\\n\\n  translate.add(transformationObj.translate,'tx',0,500).onChange(drawScene);\\n  translate.add(transformationObj.translate,'ty',0,500).onChange(drawScene);\\n  translate.add(transformationObj.translate,'tz',0,500).onChange(drawScene);\\n\\n  rotate.add(transformationObj.rotate,'rx',0,360).onChange((v)=>{ transformationObj.rotate.rx = deg_to_rad(v); drawScene();});\\n  rotate.add(transformationObj.rotate,'ry',0,360).onChange((v)=>{ transformationObj.rotate.ry = deg_to_rad(v); drawScene();});\\n  rotate.add(transformationObj.rotate,'rz',0,360).onChange((v)=>{ transformationObj.rotate.rz = deg_to_rad(v); drawScene();});\\n  \\n  scale.add(transformationObj.scale,'sx',.1,10).onChange(drawScene);\\n  scale.add(transformationObj.scale,'sy',.1,10).onChange(drawScene);\\n  scale.add(transformationObj.scale,'sz',.1,10).onChange(drawScene);\\n\\n  gui.addColor(transformationObj,'colors').onChange(drawScene);\\n */ \\n\\n\\n  var controller = new TransformController(drawScene);\\n  var transformationObj = controller.getTransformationJSON();\\n  //setupGUI();\\n  \\n\\n  \\n  function drawScene(){\\n    RenderFitToScreen(gl.canvas,window.devicePixelRatio);\\n\\n    // Tell WebGL how to convert from clip space to pixels\\n    gl.viewport(0,0,gl.canvas.width,gl.canvas.height);\\n\\n    //clear the canvas\\n    gl.clearColor(0.05,0.5,0.09,0);\\n    gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);\\n\\n    //tell it to use our program (pair of shaders)\\n    gl.useProgram(program);\\n\\n    //bind the attribute/buffer set we want.\\n    gl.bindVertexArray(vao);\\n\\n  const t = transformationObj.translate;\\n  const r = transformationObj.rotate;\\n  const s = transformationObj.scale;\\n  const c = transformationObj.color;\\n\\n    //set the color\\n    gl.uniform4f(colorLocation,c.r,c.g,c.b,c.a);\\n\\n    //compute matrix\\n    var matrix = m4.projection(gl.canvas.clientWidth,gl.canvas.clientHeight, 400);\\n    matrix = m4.translate(matrix, t.tx,t.ty,t.tz);\\n    matrix = m4.xRotate(matrix, r.rx);\\n    matrix = m4.yRotate(matrix, r.ry);\\n    matrix = m4.zRotate(matrix, r.rz);\\n    matrix = m4.scale(matrix, s.sx,s.sy,s.sz);\\n\\n    //set the matrix\\n    gl.uniformMatrix4fv(matrixLocation,false,matrix);\\n\\n    //draw the geometry\\n    var primitiveType = gl.TRIANGLES;\\n    var offset = 0;\\n    var count = 18;\\n    gl.drawArrays(primitiveType, offset, count);\\n  }\\n\\n}\\n\\nmain();\\n\\n\\n\",\n  \"html\": \"<title>Step1-WebGL 3D</title>\\n<canvas id=\\\"canvas\\\"></canvas>\\n\\n<script src=\\\"https://cdn.jsdelivr.net/gh/engineer-work/WebGL-lib@f4fff51/shaders/shaderLoader.js\\\"></script>\\n<script src=\\\"https://cdn.jsdelivr.net/gh/engineer-work/WebGL-lib@866810f/render/render_fit_to_screen.js\\\"></script>\\n<script src=\\\"https://cdn.jsdelivr.net/gh/engineer-work/WebGL-lib@49670fb/geometry/english/2d/f.js\\\"></script>\\n<script src=\\\"https://cdn.jsdelivr.net/gh/engineer-work/WebGL-lib@de66d06/transform/matrix/m4.js\\\"></script>\\n<script src=\\\"https://cdn.jsdelivr.net/npm/lil-gui@0.21\\\"></script>\\n<script src=\\\"https://cdn.jsdelivr.net/gh/engineer-work/WebGL-lib@75b9125/transform/controller/transform_controller.js\\\"></script>\\n\\n\",\n  \"css\": \"body {\\r\\n  margin: 0;\\r\\n}\\r\\ncanvas {\\r\\n  width: 100vw;\\r\\n  height: 100vh;\\r\\n  display: block;\\r\\n}\\r\\n\",\n  \"internal_block_id\": \"ide-941a20b4-7fed-48cd-9622-c1ba84bdb406\"\n}\n```",
      "createdAt": 1768821554214
    },
    {
      "id": "a500c5c4-8dd0-4523-8961-a0ed932e6557",
      "parentId": "8599598d-70cd-4cd8-96a4-102bf8c681fc",
      "name": "1. Orthographic 3D",
      "type": "FOLDER",
      "content": "",
      "createdAt": 1768821562229
    },
    {
      "id": "75a2ff12-e47b-4692-a389-6cc6e68fc676",
      "parentId": "a500c5c4-8dd0-4523-8961-a0ed932e6557",
      "name": "orthographic_3d_notes",
      "type": "FILE",
      "content": "# Orthographic 3D\n\n### For 2D : \n\n```c\n#version 300 es\n \n// an attribute is an input (in) to a vertex shader.\n// It will receive data from a buffer\nin vec2 a_position;\n \n// A matrix to transform the positions by\nuniform mat3 u_matrix;\n \n// all shaders have a main function\nvoid main() {\n  // Multiply the position by the matrix.\n  gl_Position = vec4((u_matrix * vec3(a_position, 1)).xy, 0, 1);\n}\n```\n\n### From 2D to 3D:\n\n```c\n// an attribute is an input (in) to a vertex shader.\n// It will receive data from a buffer\nin vec4 a_position;\n \n// A matrix to transform the positions by\nuniform mat4 u_matrix;\n \n// all shaders have a main function\nvoid main() {\n  // Multiply the position by the matrix.\n  gl_Position = u_matrix * a_position;\n}\n```\n\n### Old 2D projection :\n\n```c\n  projection: function (width, height) {\n    // Note: This matrix flips the Y axis so 0 is at the top.\n    return [\n      2 / width, 0, 0,\n      0, -2 / height, 0,\n      -1, 1, 1\n    ];\n  },\n}\n```\n\n### New 3D Project\n> Which convented from pixels to clip space. \n\n```c\n projection: function(width, height, depth) {\n    // Note: This matrix flips the Y axis so 0 is at the top.\n    return [\n       2 / width, 0, 0, 0,\n       0, -2 / height, 0, 0,\n       0, 0, 2 / depth, 0,\n      -1, 1, 0, 1,\n    ];\n  },\n```\n\n# Step 1 - WebGL 3D\n\n```ide\n{\n  \"js\": \"var vertexShaderSource = `#version 300 es\\r\\n\\r\\n// an attribute is an input (in) to a vertex shader.\\r\\n// It will receive data from a buffer\\r\\nin vec4 a_position;\\r\\n\\r\\n// A matrix to transform the positions by\\r\\nuniform mat4 u_matrix;\\r\\n\\r\\nvoid main(){\\r\\n gl_Position = u_matrix * a_position;\\r\\n}\\r\\n`;\\r\\nvar fragmentShaderSource = `#version 300 es\\r\\n\\r\\nprecision highp float;\\r\\nuniform vec4 u_color;\\r\\nout vec4 outColor;\\r\\n\\r\\nvoid main(){\\r\\n outColor = u_color;\\r\\n}\\r\\n`;\\r\\n\\r\\n//create geometry\\r\\nfunction setGeometry(gl){\\r\\n  gl.bufferData(gl.ARRAY_BUFFER,F_2D.positions,gl.STATIC_DRAW);\\r\\n}\\r\\nvar GUI = lil.GUI;\\r\\n\\r\\nfunction main(){\\r\\n\\r\\n\\r\\n  var canvas = document.querySelector(\\\"#canvas\\\");\\r\\n  var gl = canvas.getContext(\\\"webgl2\\\");\\r\\n  if(!gl) return;\\r\\n  \\r\\n  var program = webglUtils.generate(gl, vertexShaderSource, fragmentShaderSource);\\r\\n\\r\\n  //loop up where the vertex data need to go.\\r\\n  var positionAttributeLocation = gl.getAttribLocation(program,\\\"a_position\\\");\\r\\n\\r\\n  //loop up uniform locations\\r\\n  var colorLocation = gl.getUniformLocation(program, \\\"u_color\\\");\\r\\n  var matrixLocation = gl.getUniformLocation(program, \\\"u_matrix\\\");\\r\\n\\r\\n  //create a buffer\\r\\n  var positionBuffer = gl.createBuffer();\\r\\n\\r\\n  //create a vertex array object (attribute state)\\r\\n  var vao = gl.createVertexArray();\\r\\n\\r\\n  //and make it the one we're currently working with\\r\\n  gl.bindVertexArray(vao);\\r\\n  \\r\\n  //turn on the attribute\\r\\n  gl.enableVertexAttribArray(positionAttributeLocation);\\r\\n\\r\\n  //bind it to ARRAY_BUFFER (think of it as ARRAY_BUFFER = positionBuffer)\\r\\n  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\\r\\n\\r\\n  //set geometry\\r\\n  setGeometry(gl);\\r\\n\\r\\n  //tell the attribute how to get data out of positionBuffer (ARRAY_BUFFER)\\r\\n  var size = 3 ;              // 3 components per iteration\\r\\n  var type = gl.FLOAT;        // the data is 32bit floats\\r\\n  var normalize = false;      // don't normalize the data\\r\\n  var stride = 0;             // 0 = move forward size * sizeof(type) each iteration to get the next position\\r\\n  var offset = 0;             // start at the beginning of the buffer\\r\\n\\r\\n  gl.vertexAttribPointer(positionAttributeLocation, size, type, normalize, stride, offset);\\r\\n\\r\\n  function deg_to_rad(angle){\\r\\n    return angle * (Math.PI/180.0);\\r\\n  }\\r\\n  \\r\\n  //------------------------------------------------UI Control Part-------------------------------------------------------------------\\r\\n  // initial\\r\\n  var translation = {tx:45, ty:150, tz:0};\\r\\n  var rotation = {rx:deg_to_rad(40),ry:deg_to_rad(25),rz:deg_to_rad(325)};\\r\\n  var scaling = {sx:1, sy:1, sz:1};\\r\\n  var colors = {r:Math.random(),g: Math.random(),b: Math.random(), a:1};\\r\\n\\r\\n\\r\\n  var transformationObj = {\\r\\n    'translate':translation,\\r\\n    'rotate':rotation,\\r\\n    'scale':scaling,\\r\\n    'colors':colors \\r\\n  };\\r\\n   \\r\\n\\r\\n  const gui = new GUI();\\r\\n  gui.add(document,'title');\\r\\n \\r\\n  const translate = gui.addFolder('Translate');\\r\\n  const rotate = gui.addFolder('Rotate');\\r\\n  const scale = gui.addFolder('Scale');\\r\\n\\r\\n  translate.add(transformationObj.translate,'tx',0,500).onChange(drawScene);\\r\\n  translate.add(transformationObj.translate,'ty',0,500).onChange(drawScene);\\r\\n  translate.add(transformationObj.translate,'tz',0,500).onChange(drawScene);\\r\\n\\r\\n    rotate.add(transformationObj.rotate,'rx',0,360).onChange(drawScene);\\r\\n  rotate.add(transformationObj.rotate,'ry',0,360).onChange(drawScene);\\r\\n  rotate.add(transformationObj.rotate,'rz',0,360).onChange(drawScene);\\r\\n\\r\\n  scale.add(transformationObj.scale,'sx',.1,10).onChange(drawScene);\\r\\n  scale.add(transformationObj.scale,'sy',.1,10).onChange(drawScene);\\r\\n  scale.add(transformationObj.scale,'sz',.1,10).onChange(drawScene);\\r\\n\\r\\n  gui.addColor(transformationObj,'colors').onChange(drawScene);\\r\\n  \\r\\n  //--------------------------------------------------------------------------------------------------------------------------------------\\r\\n\\r\\n  drawScene();\\r\\n  \\r\\n  function drawScene(){\\r\\n    RenderFitToScreen(gl.canvas,window.devicePixelRatio);\\r\\n\\r\\n    // Tell WebGL how to convert from clip space to pixels\\r\\n    gl.viewport(0,0,gl.canvas.width,gl.canvas.height);\\r\\n\\r\\n    //clear the canvas\\r\\n    gl.clearColor(0.05,0.5,0.09,0);\\r\\n    gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);\\r\\n\\r\\n    //tell it to use our program (pair of shaders)\\r\\n    gl.useProgram(program);\\r\\n\\r\\n    //bind the attribute/buffer set we want.\\r\\n    gl.bindVertexArray(vao);\\r\\n\\r\\n  const t = transformationObj.translate;\\r\\n  const r = transformationObj.rotate;\\r\\n  const s = transformationObj.scale;\\r\\n  const c = transformationObj.colors;\\r\\n\\r\\n    //set the color\\r\\n    gl.uniform4f(colorLocation,c.r,c.g,c.b,c.a);\\r\\n\\r\\n    //compute matrix\\r\\n    var matrix = m4.projection(gl.canvas.clientWidth,gl.canvas.clientHeight, 400);\\r\\n    matrix = m4.translate(matrix, t.tx,t.ty,t.tz);\\r\\n   matrix = m4.xRotate(matrix, deg_to_rad(r.rx));\\r\\n    matrix = m4.yRotate(matrix, deg_to_rad(r.ry));\\r\\n    matrix = m4.zRotate(matrix, deg_to_rad(r.rz));\\r\\n    matrix = m4.scale(matrix, s.sx,s.sy,s.sz);\\r\\n     \\r\\n    //set the matrix\\r\\n    gl.uniformMatrix4fv(matrixLocation,false,matrix);\\r\\n\\r\\n    //draw the geometry\\r\\n    var primitiveType = gl.TRIANGLES;\\r\\n    var offset = 0;\\r\\n    var count = 18;\\r\\n    gl.drawArrays(primitiveType, offset, count);\\r\\n  }\\r\\n\\r\\n}\\r\\n\\r\\nmain();\\r\\n\\r\\n\\r\\n\",\n  \"html\": \"<canvas id=\\\"canvas\\\"></canvas>\\r\\n<title>Step 1 - WebGL 3D</title>\\r\\n<script src=\\\"https://cdn.jsdelivr.net/gh/engineer-work/WebGL-lib@f4fff51/shaders/shaderLoader.js\\\"></script>\\r\\n<script src=\\\"https://cdn.jsdelivr.net/gh/engineer-work/WebGL-lib@866810f/render/render_fit_to_screen.js\\\"></script>\\r\\n<script src=\\\"https://cdn.jsdelivr.net/gh/engineer-work/WebGL-lib@49670fb/geometry/english/2d/f.js\\\"></script>\\r\\n<script src=\\\"https://cdn.jsdelivr.net/gh/engineer-work/WebGL-lib@cb01d04/transform/matrix/m4.js\\\"></script>\\r\\n<script src=\\\"https://cdn.jsdelivr.net/npm/lil-gui@0.21\\\"></script>\\r\\n\",\n  \"css\": \" body { margin: 0 }\\n\\ncanvas {\\n  width: 100vw;\\n  height: 100vh;\\n  display: block;\\n}\",\n  \"internal_block_id\": \"ide-941a20b4-7fed-48cd-9622-c1ba84bdb406\"\n}\n```\n\n# Step 2 - 2D 'F' to 3D 'F'\n\n```ide\n{\n  \"js\": \"var vertexShaderSource = `#version 300 es\\r\\n//it will receive data from a buffer\\r\\nin vec4 a_position;\\r\\n\\r\\n//a matrix to transform the position by\\r\\nuniform mat4 u_matrix;\\r\\n\\r\\nvoid main(){\\r\\n gl_Position = u_matrix * a_position;\\r\\n}\\r\\n`;\\r\\nvar fragmentShaderSource = `#version 300 es\\r\\nprecision highp float;\\r\\nuniform vec4 u_color;\\r\\nout vec4 outColor;\\r\\n\\r\\nvoid main(){\\r\\n outColor = u_color;\\r\\n}\\r\\n`;\\r\\n\\r\\nvar GUI = lil.GUI;\\r\\n\\r\\nfunction setGeometry(gl){\\r\\n gl.bufferData(gl.ARRAY_BUFFER,F_3D.positions,gl.STATIC_DRAW);\\r\\n}\\r\\n\\r\\nfunction main(){\\r\\nvar canvas = document.querySelector(\\\"#canvas\\\");\\r\\nvar gl = canvas.getContext(\\\"webgl2\\\");\\r\\nif (!gl) return;\\r\\n\\r\\nvar program = webglUtils.generate(gl,vertexShaderSource,fragmentShaderSource);\\r\\n\\r\\n//look up where the vertex data need to go\\r\\nvar positionAttributeLocation = gl.getAttribLocation(program,\\\"a_position\\\");\\r\\n\\r\\n//look up uniform locations\\r\\nvar colorLocation = gl.getUniformLocation(program, \\\"u_color\\\");\\r\\nvar matrixLocation = gl.getUniformLocation(program,\\\"u_matrix\\\");\\r\\n\\r\\n//create a buffer\\r\\nvar positionBuffer = gl.createBuffer();\\r\\n\\r\\n//create a vertex array object (attribute state)\\r\\nvar vao = gl.createVertexArray();\\r\\n\\r\\n//and make it the one we're currently working with\\r\\ngl. bindVertexArray(vao);\\r\\n\\r\\n//turn on the attribute\\r\\ngl.enableVertexAttribArray(positionAttributeLocation);\\r\\n\\r\\n//Bind it to ARRAY_BUFFER (think of it as ARRAY_BUFFER = positionBuffer)\\r\\ngl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\\r\\n\\r\\n//setGeometry\\r\\nsetGeometry(gl);\\r\\n\\r\\n//tell the attribute how to get data out of positionBuffer (ARRAY_BUFFER)\\r\\nvar size = 3;\\r\\nvar type = gl.FLOAT;\\r\\nvar normalize = false;\\r\\nvar stride = 0;\\r\\nvar offset = 0;\\r\\n\\r\\ngl.vertexAttribPointer(positionAttributeLocation,size,type,normalize,stride,offset);\\r\\n\\r\\n function deg_to_rad(angle){\\r\\n    return angle * (Math.PI/180.0);\\r\\n  }\\r\\n  \\r\\n\\r\\n//------------------------------------------------UI Control Part-------------------------------------------------------------------\\r\\n  // initial\\r\\n  var translation = {tx:45, ty:150, tz:0};\\r\\n  var rotation = {rx:deg_to_rad(40),ry:deg_to_rad(25),rz:deg_to_rad(325)};\\r\\n  var scaling = {sx:1, sy:1, sz:1};\\r\\n  var colors = {r:Math.random(),g: Math.random(),b: Math.random(), a:1};\\r\\n\\r\\n\\r\\n  var transformationObj = {\\r\\n    'translate':translation,\\r\\n    'rotate':rotation,\\r\\n    'scale':scaling,\\r\\n    'colors':colors \\r\\n  };\\r\\n   \\r\\n\\r\\n  const gui = new GUI();\\r\\n  gui.add(document,'title');\\r\\n \\r\\n  const translate = gui.addFolder('Translate');\\r\\n  const rotate = gui.addFolder('Rotate');\\r\\n  const scale = gui.addFolder('Scale');\\r\\n\\r\\n  translate.add(transformationObj.translate,'tx',0,500).onChange(drawScene);\\r\\n  translate.add(transformationObj.translate,'ty',0,500).onChange(drawScene);\\r\\n  translate.add(transformationObj.translate,'tz',0,500).onChange(drawScene);\\r\\n\\r\\n  rotate.add(transformationObj.rotate,'rx',0,360).onChange(drawScene);\\r\\n  rotate.add(transformationObj.rotate,'ry',0,360).onChange(drawScene);\\r\\n  rotate.add(transformationObj.rotate,'rz',0,360).onChange(drawScene);\\r\\n  \\r\\n  scale.add(transformationObj.scale,'sx',.1,10).onChange(drawScene);\\r\\n  scale.add(transformationObj.scale,'sy',.1,10).onChange(drawScene);\\r\\n  scale.add(transformationObj.scale,'sz',.1,10).onChange(drawScene);\\r\\n\\r\\n  gui.addColor(transformationObj,'colors').onChange(drawScene);\\r\\n  \\r\\n  //--------------------------------------------------------------------------------------------------------------------------------------\\r\\n\\r\\n\\r\\n\\r\\ndrawScene();\\r\\n\\r\\nfunction drawScene(){\\r\\n   RenderFitToScreen(gl.canvas,window.devicePixelRatio);\\r\\n\\r\\n   //tell WebGL how to convert from clip space to pixels\\r\\n   gl.viewport(0,0,gl.canvas.width,gl.canvas.height);\\r\\n\\r\\n   //clear the canvas\\r\\n   gl.clearColor(0.1,0.4,0.1,0);\\r\\n   gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\\r\\n   \\r\\n   //tell it to use our program (pair of shaders)\\r\\n   gl.useProgram(program);\\r\\n\\r\\n   //bind the attribute/buffer set we want.\\r\\n   gl.bindVertexArray(vao);\\r\\n\\r\\n    const t = transformationObj.translate;\\r\\n  const r = transformationObj.rotate;\\r\\n  const s = transformationObj.scale;\\r\\n  const c = transformationObj.colors;\\r\\n   \\r\\n   //set the color\\r\\n    gl.uniform4f(colorLocation,c.r,c.g,c.b,c.a);\\r\\n\\r\\n    //compute matrix\\r\\n    var matrix = m4.projection(gl.canvas.clientWidth,gl.canvas.clientHeight, 400);\\r\\n    matrix = m4.translate(matrix, t.tx,t.ty,t.tz);\\r\\n    matrix = m4.xRotate(matrix, deg_to_rad(r.rx));\\r\\n    matrix = m4.yRotate(matrix, deg_to_rad(r.ry));\\r\\n    matrix = m4.zRotate(matrix, deg_to_rad(r.rz));\\r\\n    matrix = m4.scale(matrix, s.sx,s.sy,s.sz);\\r\\n\\r\\n    //set the matrix\\r\\n    gl.uniformMatrix4fv(matrixLocation,false,matrix);\\r\\n\\r\\n   //Draw the geometry\\r\\n   var primitiveType = gl.TRIANGLES;\\r\\n   var offset = 0;\\r\\n   var count = 16*6;\\r\\n   gl.drawArrays(primitiveType, offset, count);\\r\\n\\r\\n}\\r\\n\\r\\n}\\r\\n\\r\\nmain();\",\n  \"html\": \"<canvas id=\\\"canvas\\\"></canvas>\\r\\n<title>Step 2 - 2D 'F' to 3D 'F'</title>\\r\\n<script src=\\\"https://cdn.jsdelivr.net/gh/engineer-work/WebGL-lib@f4fff51/shaders/shaderLoader.js\\\"></script>\\r\\n<script src=\\\"https://cdn.jsdelivr.net/gh/engineer-work/WebGL-lib@866810f/render/render_fit_to_screen.js\\\"></script>\\r\\n<script src=\\\"https://cdn.jsdelivr.net/gh/engineer-work/WebGL-lib@d3882bc/geometry/english/3d/f.js\\\"></script>\\r\\n<script src=\\\"https://cdn.jsdelivr.net/gh/engineer-work/WebGL-lib@cb01d04/transform/matrix/m4.js\\\"></script>\\r\\n<script src=\\\"https://cdn.jsdelivr.net/npm/lil-gui@0.21\\\"></script>\\r\\n\",\n  \"css\": \" body { margin: 0 }\\r\\n\\r\\ncanvas {\\r\\n  width: 100vw;\\r\\n  height: 100vh;\\r\\n  display: block;\\r\\n}\",\n  \"internal_block_id\": \"ide-3c0e56fe-8b4f-4182-bdc6-5410e78edbe1\"\n}\n```\n\n# Step 3 - WebGL\n\n### New Vertex Shader\n```c\n#version 300 es\n \n// an attribute is an input (in) to a vertex shader.\n// It will receive data from a buffer\nin vec4 a_position;\nin vec4 a_color;\n \n// A matrix to transform the positions by\nuniform mat4 u_matrix;\n \n// a varying the color to the fragment shader\nout vec4 v_color;\n \n// all shaders have a main function\nvoid main() {\n  // Multiply the position by the matrix.\n  gl_Position = u_matrix * a_position;\n \n  // Pass the color to the fragment shader.\n  v_color = a_color;\n}\n```\n\n### New Fragment Shader.\n```c\n#version 300 es\n \nprecision highp float;\n \n// the varied color passed from the vertex shader\nin vec4 v_color;\n \n// we need to declare an output for the fragment shader\nout vec4 outColor;\n \nvoid main() {\n  outColor = v_color;\n}\n```\n\n### Attribute location to supply the colors, then setup another buffer and attribute to give it the colors.\n\n```c\n  ...\n  var colorAttributeLocation = gl.getAttribLocation(program, \"a_color\");\n \n  ...\n \n  // create the color buffer, make it the current ARRAY_BUFFER\n  // and copy in the color values\n  var colorBuffer = gl.createBuffer();\n  gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);\n  setColors(gl);\n \n  // Turn on the attribute\n  gl.enableVertexAttribArray(colorAttributeLocation);\n \n  // Tell the attribute how to get data out of colorBuffer (ARRAY_BUFFER)\n  var size = 3;          // 3 components per iteration\n  var type = gl.UNSIGNED_BYTE;   // the data is 8bit unsigned bytes\n  var normalize = true;  // convert from 0-255 to 0.0-1.0\n  var stride = 0;        // 0 = move forward size * sizeof(type) each\n                         // iteration to get the next color\n  var offset = 0;        // start at the beginning of the buffer\n  gl.vertexAttribPointer(\n      colorAttributeLocation, size, type, normalize, stride, offset);\n \n  ...\n \n// Fill the buffer with colors for the 'F'.\n \nfunction setColors(gl) {\n  gl.bufferData(\n      gl.ARRAY_BUFFER,\n      new Uint8Array([\n          // left column front\n        200,  70, 120,\n        200,  70, 120,\n        200,  70, 120,\n        200,  70, 120,\n        200,  70, 120,\n        200,  70, 120,\n \n          // top rung front\n        200,  70, 120,\n        200,  70, 120,\n        ...\n        ...\n      gl.STATIC_DRAW);\n}\n```\n\n### Code for Step 3 - WebGL 3D\n\n![](https://webgl2fundamentals.org/webgl/lessons/resources/triangle-winding.svg)\n\n1. Face with MultiColor\n2. Toggle CULL_FACE\n3. Toggle DEPTH_TEST\n```ide\n{\n  \"js\": \"var vertexShaderSource = `#version 300 es\\r\\n//it will receive data from buffer\\r\\nin vec4 a_position;\\r\\nin vec4 a_color;\\r\\n\\r\\n//A matrix to transform the position by\\r\\nuniform mat4 u_matrix;\\r\\n\\r\\n// a varying the color to the fragment shader\\r\\nout vec4 v_color;\\r\\n\\r\\nvoid main(){\\r\\n  gl_Position = u_matrix * a_position;\\r\\n\\r\\n  //Pass the color to the fragment shader.\\r\\n  v_color = a_color;\\r\\n}\\r\\n`;\\r\\nvar fragmentShaderSource = `#version 300 es\\r\\nprecision highp float;\\r\\n\\r\\n//the varied color passed from the vertex shader\\r\\nin vec4 v_color;\\r\\n\\r\\n//we need to declare an output for the fragment shader\\r\\nout vec4 outColor;\\r\\n\\r\\nvoid main(){\\r\\n outColor = v_color;\\r\\n}\\r\\n`;\\r\\n\\r\\nvar GUI = lil.GUI;\\r\\n\\r\\nfunction setGeometry(gl){\\r\\n  gl.bufferData(gl.ARRAY_BUFFER,FGeometry3D.positions,gl.STATIC_DRAW);\\r\\n}\\r\\n\\r\\nfunction setColors(gl){\\r\\n  gl.bufferData(gl.ARRAY_BUFFER,FGeometry3D.colors,gl.STATIC_DRAW);\\r\\n}\\r\\n\\r\\nfunction main(){\\r\\n  var canvas = document.querySelector(\\\"#canvas\\\");\\r\\n  var gl = canvas.getContext(\\\"webgl2\\\");\\r\\n  if(!gl) return;\\r\\n\\r\\n  var program = webglUtils.generate(gl,vertexShaderSource,fragmentShaderSource);\\r\\n  \\r\\n  //look up where vertex data need to go\\r\\n  var positionAttributeLocation = gl.getAttribLocation(program, \\\"a_position\\\");\\r\\n  var colorAttributeLocation = gl.getAttribLocation(program, \\\"a_color\\\");\\r\\n\\r\\n  //loop up uniform locations\\r\\n  var matrixLocation = gl.getUniformLocation(program, \\\"u_matrix\\\");\\r\\n\\r\\n  //create a buffer\\r\\n  var positionBuffer = gl.createBuffer();\\r\\n\\r\\n  //create a vertex array object (attribute state)\\r\\n  var vao = gl.createVertexArray();\\r\\n\\r\\n  //and make it the one we're currently working with\\r\\n  gl.bindVertexArray(vao);\\r\\n\\r\\n  //turn on the attribute\\r\\n  gl.enableVertexAttribArray(positionAttributeLocation);\\r\\n\\r\\n  //bind it to ARRAY_BUFFER (think of it as ARRAY_BUFFER = positionBuffer)\\r\\n  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\\r\\n\\r\\n  //set geometry\\r\\n  setGeometry(gl);\\r\\n\\r\\n  //tell the attribute how to get data out of positionBuffer (ARRAY_BUFFER\\r\\n  var size = 3;\\r\\n  var type = gl.FLOAT;\\r\\n  var normalize = false;\\r\\n  var stride = 0;\\r\\n  var offset = 0;\\r\\n\\r\\n  gl.vertexAttribPointer(positionAttributeLocation,size,type,normalize,stride,offset);\\r\\n\\r\\n  // create the color buffer, make it the current ARRAY_BUFFER\\r\\n  // and copy in the color values\\r\\n  var colorBuffer = gl.createBuffer();\\r\\n  gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);\\r\\n  gl.enableVertexAttribArray(colorAttributeLocation);\\r\\n\\r\\n  setColors(gl);\\r\\n\\r\\n  //turn on the attribute\\r\\n\\r\\n  //Turn on the attribue\\r\\n  var size1 = 3;\\r\\n  var type1 = gl.UNSIGNED_BYTE;\\r\\n  var normalize1 = true;\\r\\n  var stride1 = 0;\\r\\n  var offset1 =0;\\r\\n\\r\\n  gl.vertexAttribPointer(colorAttributeLocation, size1, type1, normalize1, stride1, offset1);     \\r\\n\\r\\nfunction deg_to_rad(angle){\\r\\n    return angle * (Math.PI/180.0);\\r\\n}\\r\\n\\r\\nfunction rad_to_deg(rad){\\r\\n    return rad * (180.0/Math.PI);\\r\\n}\\r\\n\\r\\n\\r\\n//------------------------------------------------UI Control Part-------------------------------------------------------------------\\r\\n  // initial\\r\\n  var translation = {tx:45, ty:150, tz:0};\\r\\n  var rotation = {rx:deg_to_rad(40),ry:deg_to_rad(25),rz:deg_to_rad(325)};\\r\\n  \\r\\n  //var translation = [-150, 0, -360];\\r\\n  //var translation = {tx:-150, ty:0, tz:-360};\\r\\n  //var rotation = {rx:deg_to_rad(190),ry:deg_to_rad(40),rz:deg_to_rad(30)};\\r\\n  \\r\\n\\r\\n  var scaling = {sx:1, sy:1, sz:1};\\r\\n  var colors = {r:Math.random(),g: Math.random(),b: Math.random(), a:1};\\r\\n\\r\\n  var transformationObj = {\\r\\n    'translate':translation,\\r\\n    'rotate':rotation,\\r\\n    'scale':scaling,\\r\\n    'colors':colors \\r\\n  };\\r\\n\\r\\n  var isfeature = {\\r\\n    'cull_face':false,\\r\\n    'depth_test':false,\\r\\n    'ortho':false,  \\r\\n  }\\r\\n   \\r\\n\\r\\n  const gui = new GUI();\\r\\n  gui.add(document,'title');\\r\\n \\r\\n  const translate = gui.addFolder('Translate');\\r\\n  const rotate = gui.addFolder('Rotate');\\r\\n  const scale = gui.addFolder('Scale');\\r\\n\\r\\n  translate.add(transformationObj.translate,'tx',0,500).onChange(drawScene);\\r\\n  translate.add(transformationObj.translate,'ty',0,500).onChange(drawScene);\\r\\n  translate.add(transformationObj.translate,'tz',0,500).onChange(drawScene);\\r\\n\\r\\n  rotate.add(transformationObj.rotate,'rx',0,360).onChange(drawScene);\\r\\n  rotate.add(transformationObj.rotate,'ry',0,360).onChange(drawScene);\\r\\n  rotate.add(transformationObj.rotate,'rz',0,360).onChange(drawScene);\\r\\n  \\r\\n  scale.add(transformationObj.scale,'sx',.1,10).onChange(drawScene);\\r\\n  scale.add(transformationObj.scale,'sy',.1,10).onChange(drawScene);\\r\\n  scale.add(transformationObj.scale,'sz',.1,10).onChange(drawScene);\\r\\n\\r\\n  gui.addColor(transformationObj,'colors').onChange(drawScene);\\r\\n  \\r\\n  gui.add(isfeature,'cull_face').name('CULL FACE').onChange((v)=>{\\r\\n   if(v){\\r\\n    gl.enable(gl.CULL_FACE);\\r\\n    drawScene();\\r\\n   }else{\\r\\n    gl.disable(gl.CULL_FACE);\\r\\n    drawScene();\\r\\n   }\\r\\n  });\\r\\n\\r\\n\\r\\n   gui.add(isfeature,'depth_test').name('DEPTH TEST').onChange((v)=>{\\r\\n   if(v){\\r\\n    gl.enable(gl.DEPTH_TEST);\\r\\n    drawScene();\\r\\n   }else{\\r\\n    gl.disable(gl.DEPTH_TEST);\\r\\n    drawScene();\\r\\n   }\\r\\n  });\\r\\n\\r\\n//  var matrix;\\r\\n//    gui.add(isfeature,'ortho').name('Orthogonal Projection').onChange((v)=>{\\r\\n//    if(v){\\r\\n//     var left = 0;\\r\\n//     var right = gl.canvas.clientWidth;\\r\\n//     var bottom = gl.canvas.clientHeight; \\r\\n//     var top = 0;\\r\\n//     var near = 200;\\r\\n//    var far = -200;\\r\\n//     matrix = m4.orthographic(left, right, bottom, top, near, far);\\r\\n\\r\\n    \\r\\n//     drawScene();\\r\\n//    }else{\\r\\n\\r\\n// matrix = m4.perspective(fieldOfViewRadians, aspect, zNear, zFar);\\r\\n// var fieldOfViewRadians = deg_to_rad(60);\\r\\n//     var aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;\\r\\n//     var zNear = 1;\\r\\n//     var zFar = 2000;\\r\\n//      matrix = m4.perspective(fieldOfViewRadians, aspect, zNear, zFar);\\r\\n\\r\\n//     drawScene();\\r\\n//    }\\r\\n//   });\\r\\n  \\r\\n\\r\\n  //--------------------------------------------------------------------------------------------------------------------------------------\\r\\n\\r\\n\\r\\n  drawScene();\\r\\n  \\r\\n  function drawScene(){\\r\\n\\r\\n   RenderFitToScreen(gl.canvas,window.devicePixelRatio);\\r\\n   //tell webgl how to convert from clip space to pixel\\r\\n   gl.viewport(0,0,gl.canvas.width,gl.canvas.height);\\r\\n  \\r\\n   gl.clearColor(0.1,0.4,0.2,0.0);\\r\\n   gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\\r\\n   \\r\\n\\r\\n\\r\\n   gl.useProgram(program);\\r\\n\\r\\n   gl.bindVertexArray(vao);\\r\\n\\r\\n   //Matrix\\r\\n   \\r\\n  const t = transformationObj.translate;\\r\\n  const r = transformationObj.rotate;\\r\\n  const s = transformationObj.scale;\\r\\n  const c = transformationObj.colors;\\r\\n   \\r\\n   \\r\\n   //set the color\\r\\n    //gl.uniform4f(colorLocation,c.r,c.g,c.b,c.a);\\r\\n\\r\\n    //compute matrix\\r\\n    var matrix = m4.projection(gl.canvas.clientWidth,gl.canvas.clientHeight, 400);\\r\\n\\r\\n    //  var left = 0;\\r\\n    // var right = gl.canvas.clientWidth;\\r\\n    // var bottom = gl.canvas.clientHeight; \\r\\n    // var top = 0;\\r\\n    // var near = 200;\\r\\n    // var far = -200;\\r\\n    //var matrix = m4.orthographic(left, right, bottom, top, near, far);\\r\\n    // var fieldOfViewRadians = deg_to_rad(60);\\r\\n    // var aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;\\r\\n    // var zNear = 1;\\r\\n    // var zFar = 2000;\\r\\n    // var matrix = m4.perspective(fieldOfViewRadians, aspect, zNear, zFar);\\r\\n     \\r\\n\\r\\n    matrix = m4.translate(matrix, t.tx,t.ty,t.tz);\\r\\n    matrix = m4.xRotate(matrix, deg_to_rad(r.rx));\\r\\n    matrix = m4.yRotate(matrix, deg_to_rad(r.ry));\\r\\n    matrix = m4.zRotate(matrix, deg_to_rad(r.rz));\\r\\n    matrix = m4.scale(matrix, s.sx,s.sy,s.sz);\\r\\n\\r\\n\\r\\n   gl.uniformMatrix4fv(matrixLocation, false, matrix);\\r\\n\\r\\n   //Draw the geometry\\r\\n   var primitiveType = gl.TRIANGLES;\\r\\n   var offset = 0;\\r\\n   var count = 16 * 6;\\r\\n   gl.drawArrays(primitiveType, offset, count);\\r\\n\\r\\n  }\\r\\n\\r\\n \\r\\n\\r\\n}\\r\\n\\r\\nmain();\",\n  \"html\": \"<canvas id=\\\"canvas\\\"></canvas>\\r\\n<title>Step 3 - F with multi color</title>\\r\\n<script src=\\\"https://cdn.jsdelivr.net/gh/engineer-work/WebGL-lib@f4fff51/shaders/shaderLoader.js\\\"></script>\\r\\n<script src=\\\"https://cdn.jsdelivr.net/gh/engineer-work/WebGL-lib@866810f/render/render_fit_to_screen.js\\\"></script>\\r\\n<script src=\\\"https://cdn.jsdelivr.net/gh/engineer-work/WebGL-lib@3ef60f3/geometry/english/3d/f_c.js\\\"></script>\\r\\n<script src=\\\"https://cdn.jsdelivr.net/gh/engineer-work/WebGL-lib@cb01d04/transform/matrix/m4.js\\\"></script>\\r\\n<script src=\\\"https://cdn.jsdelivr.net/npm/lil-gui@0.21\\\"></script>\\r\\n\",\n  \"css\": \" body { margin: 0 }\\r\\n\\r\\ncanvas {\\r\\n  width: 100vw;\\r\\n  height: 100vh;\\r\\n  display: block;\\r\\n}\",\n  \"internal_block_id\": \"ide-1f94fba5-f4df-45a6-a9ab-19fb758b687a\"\n}\n```\n\n\n\n",
      "createdAt": 1768821574669
    }
  ]
}