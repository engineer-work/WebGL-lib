{
  "version": 1,
  "nodes": [
    {
      "id": "demo-webgl",
      "parentId": "folder-demos",
      "name": "WebGL_Demo.md",
      "type": "FILE",
      "content": "# Visualizing the Camera\n\n- It’s often useful to be able to visualize what a camera sees, it’s “frustum”. This is surprisingly easy.\n- As pointed in the articles on orthographic and perspective projection those projection matrices take some space and convert them into the -1 to +1 box of clip space. \n- Further a camera matrix is just a matrix that represents some place and orientation in world space of the camera.\n\n- So, the first thing that should be kind of obvious. If we just use the camera matrix to draw something we’ll have an object representing the camera. \n\n- The complication is that a camera can’t see itself, but, using the techniques from the article on multiple views we can have 2 views. \n\n- We’ll use a different camera in each view. The 2nd view will look at the first and so will see be able to see this object we’re drawing to represent the camera used in the other view.\n\n- First let’s make some data to represent the camera. Let’s make a cube and then let’s add a cone to the end. We’re going to draw this with lines.\n\n-  We’ll use indices to connect the vertices.\n\n- Cameras view down the -Z direction so let’s put the cube and cone on the positive side with the cone opening toward -Z\n\n# Camera and Projection controller.\n  1. Camera controller.\n  2. Perspective projection controller.\n  3. Orthogonal projection controller.\n  \n\n```ide\n{\n  \"js\": \"var vertexShaderSource = `#version 300 es\\r\\n\\r\\n//it will receive data from buffer\\r\\nin vec4 a_position;\\r\\nin vec4 a_color;\\r\\n\\r\\n//A matrix to transform the positions by\\r\\nuniform mat4 u_matrix;\\r\\n\\r\\n//Varying the color to the fragment shader.\\r\\nout vec4 v_color;\\r\\n\\r\\n\\r\\nvoid main(){\\r\\n    vec4 position = u_matrix * a_position;\\r\\n    \\r\\n  \\r\\n    gl_Position = position;\\r\\n\\r\\n    v_color = a_color;\\r\\n}\\r\\n\\r\\n`;\\r\\nvar fragmentShaderSource = `#version 300 es\\r\\nprecision highp float;\\r\\n\\r\\nin vec4 v_color;\\r\\n\\r\\nout vec4 outColor;\\r\\n\\r\\nvoid main(){\\r\\n  outColor = v_color;\\r\\n}\\r\\n\\r\\n`;\\r\\n\\r\\n//------------only for camera object-------\\r\\n\\r\\nconst colorVS = `#version 300 es\\r\\nin vec4 a_position;\\r\\n\\r\\nuniform mat4 u_matrix;\\r\\n\\r\\nvoid main() {\\r\\n  // Multiply the position by the matrix.\\r\\n  gl_Position = u_matrix * a_position;\\r\\n}\\r\\n`;\\r\\n\\r\\nconst colorFS = `#version 300 es\\r\\nprecision highp float;\\r\\n\\r\\nuniform vec4 u_color;\\r\\n\\r\\nout vec4 outColor;\\r\\n\\r\\nvoid main() {\\r\\n  outColor = u_color;\\r\\n}\\r\\n`;\\r\\n\\r\\n//-----------------------------------------\\r\\n\\r\\n\\r\\nfunction setGeometry(gl){\\r\\n   gl.bufferData(gl.ARRAY_BUFFER,FGeometry3D.positions,gl.STATIC_DRAW);\\r\\n}\\r\\n\\r\\nfunction setColors(gl){\\r\\n   gl.bufferData(gl.ARRAY_BUFFER,FGeometry3D.colors,gl.STATIC_DRAW);\\r\\n}\\r\\n\\r\\nvar GUI = lil.GUI;\\r\\n\\r\\nfunction object_f(gl,positionAttributeLocation, colorAttributeLocation )\\r\\n{\\r\\n  var positionBuffer = gl.createBuffer();\\r\\n  var vao = gl.createVertexArray();\\r\\n  gl.bindVertexArray(vao);\\r\\n  gl.enableVertexAttribArray(positionAttributeLocation);\\r\\n  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\\r\\n  setGeometry(gl);\\r\\n\\r\\n  var size = 3;\\r\\n  var type = gl.FLOAT;\\r\\n  var normalize = false;\\r\\n  var stride = 0;\\r\\n  var offset = 0;\\r\\n  gl.vertexAttribPointer(positionAttributeLocation, size, type, normalize, stride, offset);\\r\\n\\r\\n  var colorBuffer = gl.createBuffer();\\r\\n\\r\\n  gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);\\r\\n  gl.enableVertexAttribArray(colorAttributeLocation);\\r\\n\\r\\n  setColors(gl);\\r\\n\\r\\n  var size_c = 3;\\r\\n  var type_c = gl.UNSIGNED_BYTE;\\r\\n  var normalize_c = true;\\r\\n  var stride_c = 0;\\r\\n  var offset_c = 0;\\r\\n\\r\\n  gl.vertexAttribPointer(colorAttributeLocation, size_c, type_c, normalize_c, stride_c, offset_c);\\r\\n\\r\\n  return vao;\\r\\n\\r\\n\\r\\n}\\r\\n\\r\\n\\r\\nfunction object_camera_ctrl(gl, positionAttributeLocation) \\r\\n{\\r\\n\\r\\n  const positions = [\\r\\n    -1, -1,  1,\\r\\n     1, -1,  1,\\r\\n    -1,  1,  1,\\r\\n     1,  1,  1,\\r\\n    -1, -1,  3,\\r\\n     1, -1,  3,\\r\\n    -1,  1,  3,\\r\\n     1,  1,  3,\\r\\n     0,  0,  1,\\r\\n  ];\\r\\n\\r\\n  const indices = [\\r\\n    0, 1, 1, 3, 3, 2, 2, 0,\\r\\n    4, 5, 5, 7, 7, 6, 6, 4,\\r\\n    0, 4, 1, 5, 3, 7, 2, 6,\\r\\n  ];\\r\\n\\r\\n  for (let i = 0; i < positions.length; i++) {\\r\\n    positions[i] *= 20;\\r\\n  }\\r\\n  \\r\\n  const vao = gl.createVertexArray();\\r\\n  gl.bindVertexArray(vao);\\r\\n\\r\\n  // ---- position buffer ----\\r\\n  const positionBuffer = gl.createBuffer();\\r\\n  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\\r\\n  gl.bufferData(\\r\\n    gl.ARRAY_BUFFER,\\r\\n    new Float32Array(positions),\\r\\n    gl.STATIC_DRAW\\r\\n  );\\r\\n\\r\\n  gl.enableVertexAttribArray(positionAttributeLocation);\\r\\n  gl.vertexAttribPointer(\\r\\n    positionAttributeLocation,\\r\\n    3,\\r\\n    gl.FLOAT,\\r\\n    false,\\r\\n    0,\\r\\n    0\\r\\n  );\\r\\n\\r\\n  // ---- index buffer ----\\r\\n  const indexBuffer = gl.createBuffer();\\r\\n  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);\\r\\n  gl.bufferData(\\r\\n    gl.ELEMENT_ARRAY_BUFFER,\\r\\n    new Uint16Array(indices),\\r\\n    gl.STATIC_DRAW\\r\\n  );\\r\\n\\r\\n  gl.bindVertexArray(vao);\\r\\n\\r\\n  return {\\r\\n    vao,\\r\\n    indexCount: indices.length\\r\\n  };\\r\\n}\\r\\n\\r\\nfunction object_perspective_ctrl(gl,positionAttributeLocation){\\r\\n  const positions = [\\r\\n      -1, -1, -1,  // cube vertices\\r\\n       1, -1, -1,\\r\\n      -1,  1, -1,\\r\\n       1,  1, -1,\\r\\n      -1, -1,  1,\\r\\n       1, -1,  1,\\r\\n      -1,  1,  1,\\r\\n       1,  1,  1,\\r\\n    ];\\r\\n    const indices = [\\r\\n      0, 1, 1, 3, 3, 2, 2, 0, // cube indices\\r\\n      4, 5, 5, 7, 7, 6, 6, 4,\\r\\n      0, 4, 1, 5, 3, 7, 2, 6,\\r\\n    ];\\r\\n\\r\\n  \\r\\n  const vao = gl.createVertexArray();\\r\\n  gl.bindVertexArray(vao);\\r\\n\\r\\n    // ---- position buffer ----\\r\\n  const positionBuffer = gl.createBuffer();\\r\\n  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\\r\\n  gl.bufferData(\\r\\n    gl.ARRAY_BUFFER,\\r\\n    new Float32Array(positions),\\r\\n    gl.STATIC_DRAW\\r\\n  );\\r\\n\\r\\n  gl.enableVertexAttribArray(positionAttributeLocation);\\r\\n  gl.vertexAttribPointer(\\r\\n    positionAttributeLocation,\\r\\n    3,\\r\\n    gl.FLOAT,\\r\\n    false,\\r\\n    0,\\r\\n    0\\r\\n  );\\r\\n\\r\\n  // ---- index buffer ----\\r\\n  const indexBuffer = gl.createBuffer();\\r\\n  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);\\r\\n  gl.bufferData(\\r\\n    gl.ELEMENT_ARRAY_BUFFER,\\r\\n    new Uint16Array(indices),\\r\\n    gl.STATIC_DRAW\\r\\n  );\\r\\n\\r\\n  gl.bindVertexArray(vao);\\r\\n\\r\\n  return {\\r\\n    vao,\\r\\n    indexCount: indices.length\\r\\n  };\\r\\n\\r\\n}\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\nfunction main(){\\r\\n\\r\\n\\r\\n\\r\\nvar canvas = document.querySelector(\\\"#canvas\\\");\\r\\nvar gl = canvas.getContext(\\\"webgl2\\\");\\r\\nif(!gl) return;\\r\\n\\r\\n//----------------------Object F-----------------------------------------------\\r\\nvar program = webglUtils.generate(gl,vertexShaderSource,fragmentShaderSource);\\r\\n//lookup the vertex data to send\\r\\nvar positionAttributeLocation = gl.getAttribLocation(program, \\\"a_position\\\");\\r\\nvar colorAttributeLocation = gl.getAttribLocation(program, \\\"a_color\\\");\\r\\n// lookup the uniform data to send\\r\\nvar matrixLocation = gl.getUniformLocation(program,\\\"u_matrix\\\");\\r\\nvar vao = object_f(gl,positionAttributeLocation, colorAttributeLocation);\\r\\n//----------------------------------------------------------------------------\\r\\nvar camera_ctrl_program = webglUtils.generate(gl,colorVS,colorFS);\\r\\nvar camera_ctrl_positionAttributeLocation = gl.getAttribLocation(camera_ctrl_program, \\\"a_position\\\");\\r\\nvar camera_ctrl_colorAttributeLocation = gl.getUniformLocation(camera_ctrl_program, \\\"u_color\\\");\\r\\nvar camera_ctrl_matrixUniformLocation = gl.getUniformLocation(camera_ctrl_program, \\\"u_matrix\\\");\\r\\nvar camera_vao = object_camera_ctrl(gl,camera_ctrl_positionAttributeLocation);\\r\\nvar perspective_vao = object_perspective_ctrl(gl,camera_ctrl_positionAttributeLocation);\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\nfunction deg_to_rad(d) {\\r\\n    return d * Math.PI / 180;\\r\\n}\\r\\n\\r\\n//------------------------------------------------UI Control Part-------------------------------------------------------------------\\r\\n  // initial\\r\\n  //var translation = {tx:45, ty:150, tz:0};\\r\\n  //var rotation = {rx:deg_to_rad(40),ry:deg_to_rad(25),rz:deg_to_rad(325)};\\r\\n  \\r\\n  var translation = {tx:-35, ty:-75, tz:5};\\r\\n  var rotation = {rx:deg_to_rad(190),ry:deg_to_rad(40),rz:deg_to_rad(30)};\\r\\n  var fov = 45;\\r\\n\\r\\n  var scaling = {sx:1, sy:1, sz:1};\\r\\n  var colors = {r:Math.random(),g: Math.random(),b: Math.random(), a:1};\\r\\n  var camera_position = {x:0, y:0, z:-200};\\r\\n  var isDragging = true;\\r\\n\\r\\n  var zNear = 1;\\r\\n  var zFar = 2000;\\r\\n  var isOrthographicProject = false;\\r\\n  var orthographicUnit = 120;\\r\\n\\r\\n  var transformationObj = {\\r\\n    'translate':translation,\\r\\n    'rotate':rotation,\\r\\n    'scale':scaling,\\r\\n    'colors':colors,\\r\\n    'fov':fov ,\\r\\n    'camera_position': camera_position,\\r\\n    'ui_drag':isDragging,\\r\\n    'near':zNear,\\r\\n    'far':zFar,\\r\\n    'isOrtho':isOrthographicProject,\\r\\n    'orthoUnit':orthographicUnit\\r\\n  };\\r\\n\\r\\n  \\r\\n //------------------------------------------------  \\r\\n\\r\\n  const gui = new GUI();\\r\\n // gui.domElement = gui.domElement || gui.__ul.parentElement;\\r\\n\\r\\n  gui.add(document,'title');\\r\\n  gui.add(transformationObj,'fov',1,60).name(\\\"Field of View\\\").onChange(render);\\r\\n\\r\\n  //---------\\r\\n\\r\\nconst el = gui.domElement;\\r\\n\\r\\n\\r\\n['pointerdown','pointermove','pointerup','wheel']\\r\\n  .forEach(e =>\\r\\n    gui.domElement.addEventListener(e, ev => ev.stopPropagation())\\r\\n  );\\r\\n\\r\\n\\r\\nel.style.position = 'fixed';\\r\\nel.style.left = '20px';\\r\\nel.style.top = '20px';\\r\\n\\r\\nvar offsetX, offsetY;\\r\\n\\r\\nfunction onMouseDown(e) {\\r\\n  isDragging = true;\\r\\n  offsetX = e.clientX - el.offsetLeft;\\r\\n  offsetY = e.clientY - el.offsetTop;\\r\\n}\\r\\n\\r\\nfunction onMouseMove(e) {\\r\\n  if (!isDragging) return;\\r\\n  el.style.left = `${e.clientX - offsetX}px`;\\r\\n  el.style.top = `${e.clientY - offsetY}px`;\\r\\n}\\r\\n\\r\\nfunction onMouseUp() {\\r\\n  isDragging = false;\\r\\n}\\r\\n\\r\\nfunction enableDrag() {\\r\\n  el.addEventListener('mousedown', onMouseDown);\\r\\n  document.addEventListener('mousemove', onMouseMove);\\r\\n  document.addEventListener('mouseup', onMouseUp);\\r\\n}\\r\\n\\r\\nfunction disableDrag() {\\r\\n  el.removeEventListener('mousedown', onMouseDown);\\r\\n  document.removeEventListener('mousemove', onMouseMove);\\r\\n  document.removeEventListener('mouseup', onMouseUp);\\r\\n  isDragging = false;\\r\\n}\\r\\n\\r\\n\\r\\n//---------  \\r\\n\\r\\n  gui.add(transformationObj,'ui_drag').name(\\\"Prevent UI From Dragging\\\").onChange(value => {\\r\\n    if (value) {\\r\\n      disableDrag(); // prevent dragging\\r\\n    } else {\\r\\n      enableDrag();  // allow dragging\\r\\n    }\\r\\n  });\\r\\n\\r\\n  \\r\\n  const camera_ctrl = gui.addFolder(\\\"Camera Control\\\");\\r\\n  const pers_ctrl = gui.addFolder(\\\"Far and Near\\\")\\r\\n  const obj = gui.addFolder('Object Control');\\r\\n  const translate = obj.addFolder('Translate');\\r\\n  const rotate = obj.addFolder('Rotate');\\r\\n  const scale = obj.addFolder('Scale');\\r\\n  const r = 1000;\\r\\n\\r\\n  pers_ctrl.add(transformationObj,'near',0,2000).name(\\\"Near\\\").onChange(render);\\r\\n  pers_ctrl.add(transformationObj,'far',0,2000).name(\\\"Far\\\").onChange(render);\\r\\n  pers_ctrl.add(transformationObj,'isOrtho').name(\\\"Orthographic Projection\\\").onChange(render);\\r\\n  pers_ctrl.add(transformationObj,'orthoUnit',0,120).name(\\\"Orthographic Unit\\\").onChange(render);\\r\\n  \\r\\n  \\r\\n  \\r\\n  camera_ctrl.add(transformationObj.camera_position,'x',-r,r).name(\\\"cx\\\").onChange(render);\\r\\n  camera_ctrl.add(transformationObj.camera_position,'y',-r,r).name(\\\"cy\\\").onChange(render);\\r\\n  camera_ctrl.add(transformationObj.camera_position,'z',-r,r).name(\\\"cz\\\").onChange(render);\\r\\n\\r\\n  \\r\\n  translate.add(transformationObj.translate,'tx',-r,r).onChange(render);\\r\\n  translate.add(transformationObj.translate,'ty',-r,r).onChange(render);\\r\\n  translate.add(transformationObj.translate,'tz',-2000,2000).onChange(render);\\r\\n\\r\\n  rotate.add(transformationObj.rotate,'rx',0,360).onChange(render);\\r\\n  rotate.add(transformationObj.rotate,'ry',0,360).onChange(render);\\r\\n  rotate.add(transformationObj.rotate,'rz',0,360).onChange(render);\\r\\n  \\r\\n  scale.add(transformationObj.scale,'sx',.1,10).onChange(render);\\r\\n  scale.add(transformationObj.scale,'sy',.1,10).onChange(render);\\r\\n  scale.add(transformationObj.scale,'sz',.1,10).onChange(render);\\r\\n\\r\\n  gui.addColor(transformationObj,'colors').onChange(render);\\r\\n\\r\\n\\r\\n\\r\\n//------\\r\\n\\r\\n\\r\\n\\r\\n\\r\\nfunction drawScene(projectionMatrix, cameraMatrix, worldMatrix){\\r\\n\\r\\n  \\r\\n    gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);\\r\\n\\r\\n    const viewMatrix = m4.inverse(cameraMatrix);\\r\\n\\r\\n    var matrix = m4.multiply(projectionMatrix, viewMatrix);\\r\\n    matrix = m4.multiply(matrix, worldMatrix);\\r\\n\\r\\n    gl.useProgram(program);\\r\\n    gl.bindVertexArray(vao);\\r\\n    \\r\\n    gl.uniformMatrix4fv(matrixLocation,false, matrix);\\r\\n\\r\\n\\r\\n    var primitivie = gl.TRIANGLES;\\r\\n    var offset = 0;\\r\\n    var count = 16*6;\\r\\n    gl.drawArrays(primitivie,offset,count);\\r\\n\\r\\n}\\r\\n\\r\\nfunction drawCameraControl(projectionMatrix,cameraMatrix,cameraMatrix2,color){\\r\\n    const viewMatrix = m4.inverse(cameraMatrix2);\\r\\n\\r\\n    var matrix = m4.multiply(projectionMatrix, viewMatrix);\\r\\n    matrix = m4.multiply(matrix, cameraMatrix);\\r\\n\\r\\n    gl.useProgram(camera_ctrl_program);\\r\\n    gl.bindVertexArray(camera_vao.vao);\\r\\n\\r\\n    gl.uniform4f(camera_ctrl_colorAttributeLocation, color.r,color.g, color.b, color.a);\\r\\n    \\r\\n    gl.uniformMatrix4fv(camera_ctrl_matrixUniformLocation, false, matrix);\\r\\n  \\r\\n   \\r\\n    // Draw lines\\r\\n    gl.drawElements(\\r\\n      gl.LINES,\\r\\n      camera_vao.indexCount,\\r\\n      gl.UNSIGNED_SHORT,\\r\\n      0\\r\\n    );\\r\\n\\r\\n    gl.bindVertexArray(camera_vao.vao);\\r\\n    return matrix;\\r\\n}\\r\\n\\r\\nfunction drawPerspectiveControl(projectionMatrix1,projectionMatrix2, cameraMatrix1,cameraMatrix2){\\r\\n  const viewMatrix = m4.inverse(cameraMatrix2);\\r\\n\\r\\n    var matrix = m4.multiply(projectionMatrix2, viewMatrix);\\r\\n    matrix = m4.multiply(matrix, cameraMatrix1);\\r\\n    matrix = m4.multiply(matrix, m4.inverse(projectionMatrix1));\\r\\n    gl.bindVertexArray(perspective_vao.vao);\\r\\n    gl.uniformMatrix4fv(camera_ctrl_matrixUniformLocation, false, matrix); \\r\\n  \\r\\n   \\r\\n    // Draw lines\\r\\n    gl.drawElements(\\r\\n      gl.LINES,\\r\\n      perspective_vao.indexCount,\\r\\n      gl.UNSIGNED_SHORT,\\r\\n      0\\r\\n    );\\r\\n\\r\\n    gl.bindVertexArray(perspective_vao.vao);\\r\\n  \\r\\n}\\r\\n\\r\\nfunction render(){\\r\\n  \\r\\n    RenderFitToScreen(gl.canvas, window.devicePixelRatio);\\r\\n\\r\\n    gl.enable(gl.CULL_FACE);\\r\\n    gl.enable(gl.DEPTH_TEST);\\r\\n    gl.enable(gl.SCISSOR_TEST);\\r\\n\\r\\n    var effectiveWidth = gl.canvas.clientWidth / 2.0;\\r\\n    var aspect = effectiveWidth/gl.canvas.clientHeight;\\r\\n   \\r\\n\\r\\n\\r\\n    \\r\\n    const t = transformationObj.translate;\\r\\n    const r = transformationObj.rotate;\\r\\n    const s = transformationObj.scale;\\r\\n    const c = transformationObj.colors;\\r\\n    \\r\\n \\r\\n\\r\\n\\r\\n    var camera_object = transformationObj.camera_position;    \\r\\n\\r\\n\\r\\n\\r\\n    var projectionMatrix = transformationObj.isOrtho ?\\r\\n          m4.orthographic(\\r\\n            -transformationObj.orthoUnit * aspect,\\r\\n             transformationObj.orthoUnit * aspect,\\r\\n            -transformationObj.orthoUnit,\\r\\n             transformationObj.orthoUnit,\\r\\n              transformationObj.near, transformationObj.far\\r\\n          )\\r\\n         :m4.perspective(deg_to_rad(transformationObj.fov), aspect,  transformationObj.near, transformationObj.far);\\r\\n    var cameraPosition = [camera_object.x,camera_object.y,camera_object.z];\\r\\n    var target = [0, 0, 0];\\r\\n    var up = [0 , 1, 0];\\r\\n    var cameraMatrix = m4.lookAt(cameraPosition, target, up);\\r\\n    \\r\\n    //var worldMatrix = m4.translate(worldMatrix, -35, -75, -5);\\r\\n    //var worldMatrix = m4.yRotation(deg_to_rad(r.ry));\\r\\n    //worldMatrix = m4.xRotate(worldMatrix, deg_to_rad(r.rx));\\r\\n    // center the 'F' around its origin\\r\\n    var worldMatrix = m4.translation( t.tx,t.ty,t.tz);\\r\\n    worldMatrix = m4.xRotate(worldMatrix, deg_to_rad(r.rx));\\r\\n    worldMatrix = m4.yRotate(worldMatrix, deg_to_rad(r.ry));\\r\\n    worldMatrix = m4.zRotate(worldMatrix, deg_to_rad(r.rz));\\r\\n    worldMatrix = m4.scale(worldMatrix, s.sx,s.sy,s.sz);\\r\\n\\r\\n    var {width, height} = gl.canvas;\\r\\n    var leftWidth = width / 2 | 0; \\r\\n\\r\\n    gl.viewport(0,0,leftWidth, height);\\r\\n    gl.scissor(0, 0,leftWidth, height);\\r\\n    gl.clearColor(1,0.8,0.8,1);\\r\\n\\r\\n    drawScene(projectionMatrix, cameraMatrix, worldMatrix);\\r\\n\\r\\n    //right side\\r\\n\\r\\n\\r\\n    var rightWidth = width - leftWidth;\\r\\n    gl.viewport(leftWidth,0,rightWidth,height);\\r\\n    gl.scissor(leftWidth,0,rightWidth,height);\\r\\n    gl.clearColor(0.8, 0.8, 1, 1);\\r\\n    var projectionMatrix2 = m4.perspective(deg_to_rad(transformationObj.fov), aspect,zNear,zFar);\\r\\n    var cameraPosition2 = [-600, 400, -400];\\r\\n    var target2 = [0,0,0];\\r\\n    var cameraMatrix2 = m4.lookAt(cameraPosition2,target2,up)\\r\\n\\r\\n    drawScene(projectionMatrix2, cameraMatrix2, worldMatrix);\\r\\n\\r\\n\\r\\n   drawCameraControl(projectionMatrix2,cameraMatrix,cameraMatrix2,c);\\r\\n   drawPerspectiveControl(projectionMatrix,projectionMatrix2,cameraMatrix,cameraMatrix2);\\r\\n\\r\\n\\r\\n}\\r\\n\\r\\nrender();\\r\\n\\r\\n}\\r\\n\\r\\nmain();\",\n  \"html\": \"<canvas id=\\\"canvas\\\"></canvas>\\r\\n<title>Visualizing the Camera</title>\\r\\n<script src=\\\"https://cdn.jsdelivr.net/gh/engineer-work/WebGL-lib@f4fff51/shaders/shaderLoader.js\\\"></script>\\r\\n<script src=\\\"https://cdn.jsdelivr.net/gh/engineer-work/WebGL-lib@866810f/render/render_fit_to_screen.js\\\"></script>\\r\\n<script src=\\\"https://cdn.jsdelivr.net/gh/engineer-work/WebGL-lib@3ef60f3/geometry/english/3d/f_c.js\\\"></script>\\r\\n<script src=\\\"https://cdn.jsdelivr.net/gh/engineer-work/WebGL-lib@37ac783/transform/matrix/m4_v1.js\\\"></script>\\r\\n<script src=\\\"https://cdn.jsdelivr.net/npm/lil-gui@0.21\\\"></script>\\r\\n\",\n  \"css\": \" body { margin: 0 }\\r\\n\\r\\ncanvas {\\r\\n  width: 100vw;\\r\\n  height: 100vh;\\r\\n  display: block;\\r\\n}\",\n  \"internal_block_id\": \"ide-26298513-f753-4075-9a8c-40256d68240d\"\n}\n```",
      "createdAt": 1768807949929
    },
    {
      "id": "8599598d-70cd-4cd8-96a4-102bf8c681fc",
      "parentId": null,
      "name": "Webgl-shadow",
      "type": "FOLDER",
      "content": "",
      "createdAt": 1768821532574
    },
    {
      "id": "fa8d3bc9-edb8-4bc3-9efd-26a5f176bef2",
      "parentId": "8599598d-70cd-4cd8-96a4-102bf8c681fc",
      "name": "shadow_notes",
      "type": "FILE",
      "content": "",
      "createdAt": 1768821554214
    },
    {
      "id": "a500c5c4-8dd0-4523-8961-a0ed932e6557",
      "parentId": "8599598d-70cd-4cd8-96a4-102bf8c681fc",
      "name": "1. Orthographic 3D",
      "type": "FOLDER",
      "content": "",
      "createdAt": 1768821562229
    },
    {
      "id": "75a2ff12-e47b-4692-a389-6cc6e68fc676",
      "parentId": "a500c5c4-8dd0-4523-8961-a0ed932e6557",
      "name": "orthographic_3d_notes",
      "type": "FILE",
      "content": "# Orthographic 3D\n\n### For 2D : \n\n```c\n#version 300 es\n \n// an attribute is an input (in) to a vertex shader.\n// It will receive data from a buffer\nin vec2 a_position;\n \n// A matrix to transform the positions by\nuniform mat3 u_matrix;\n \n// all shaders have a main function\nvoid main() {\n  // Multiply the position by the matrix.\n  gl_Position = vec4((u_matrix * vec3(a_position, 1)).xy, 0, 1);\n}\n```\n\n### From 2D to 3D:\n\n```c\n// an attribute is an input (in) to a vertex shader.\n// It will receive data from a buffer\nin vec4 a_position;\n \n// A matrix to transform the positions by\nuniform mat4 u_matrix;\n \n// all shaders have a main function\nvoid main() {\n  // Multiply the position by the matrix.\n  gl_Position = u_matrix * a_position;\n}\n```\n\n### Old 2D projection :\n\n```c\n  projection: function (width, height) {\n    // Note: This matrix flips the Y axis so 0 is at the top.\n    return [\n      2 / width, 0, 0,\n      0, -2 / height, 0,\n      -1, 1, 1\n    ];\n  },\n}\n```\n\n### New 3D Project\n> Which convented from pixels to clip space. \n\n```c\n projection: function(width, height, depth) {\n    // Note: This matrix flips the Y axis so 0 is at the top.\n    return [\n       2 / width, 0, 0, 0,\n       0, -2 / height, 0, 0,\n       0, 0, 2 / depth, 0,\n      -1, 1, 0, 1,\n    ];\n  },\n```\n\n# Step 1 - WebGL 3D\n\n```ide\n{\n  \"js\": \"var vertexShaderSource = `#version 300 es\\r\\n\\r\\n// an attribute is an input (in) to a vertex shader.\\r\\n// It will receive data from a buffer\\r\\nin vec4 a_position;\\r\\n\\r\\n// A matrix to transform the positions by\\r\\nuniform mat4 u_matrix;\\r\\n\\r\\nvoid main(){\\r\\n gl_Position = u_matrix * a_position;\\r\\n}\\r\\n`;\\r\\nvar fragmentShaderSource = `#version 300 es\\r\\n\\r\\nprecision highp float;\\r\\nuniform vec4 u_color;\\r\\nout vec4 outColor;\\r\\n\\r\\nvoid main(){\\r\\n outColor = u_color;\\r\\n}\\r\\n`;\\r\\n\\r\\n//create geometry\\r\\nfunction setGeometry(gl){\\r\\n  gl.bufferData(gl.ARRAY_BUFFER,F_2D.positions,gl.STATIC_DRAW);\\r\\n}\\r\\nvar GUI = lil.GUI;\\r\\n\\r\\nfunction main(){\\r\\n\\r\\n\\r\\n  var canvas = document.querySelector(\\\"#canvas\\\");\\r\\n  var gl = canvas.getContext(\\\"webgl2\\\");\\r\\n  if(!gl) return;\\r\\n  \\r\\n  var program = webglUtils.generate(gl, vertexShaderSource, fragmentShaderSource);\\r\\n\\r\\n  //loop up where the vertex data need to go.\\r\\n  var positionAttributeLocation = gl.getAttribLocation(program,\\\"a_position\\\");\\r\\n\\r\\n  //loop up uniform locations\\r\\n  var colorLocation = gl.getUniformLocation(program, \\\"u_color\\\");\\r\\n  var matrixLocation = gl.getUniformLocation(program, \\\"u_matrix\\\");\\r\\n\\r\\n  //create a buffer\\r\\n  var positionBuffer = gl.createBuffer();\\r\\n\\r\\n  //create a vertex array object (attribute state)\\r\\n  var vao = gl.createVertexArray();\\r\\n\\r\\n  //and make it the one we're currently working with\\r\\n  gl.bindVertexArray(vao);\\r\\n  \\r\\n  //turn on the attribute\\r\\n  gl.enableVertexAttribArray(positionAttributeLocation);\\r\\n\\r\\n  //bind it to ARRAY_BUFFER (think of it as ARRAY_BUFFER = positionBuffer)\\r\\n  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\\r\\n\\r\\n  //set geometry\\r\\n  setGeometry(gl);\\r\\n\\r\\n  //tell the attribute how to get data out of positionBuffer (ARRAY_BUFFER)\\r\\n  var size = 3 ;              // 3 components per iteration\\r\\n  var type = gl.FLOAT;        // the data is 32bit floats\\r\\n  var normalize = false;      // don't normalize the data\\r\\n  var stride = 0;             // 0 = move forward size * sizeof(type) each iteration to get the next position\\r\\n  var offset = 0;             // start at the beginning of the buffer\\r\\n\\r\\n  gl.vertexAttribPointer(positionAttributeLocation, size, type, normalize, stride, offset);\\r\\n\\r\\n  function deg_to_rad(angle){\\r\\n    return angle * (Math.PI/180.0);\\r\\n  }\\r\\n  \\r\\n  //------------------------------------------------UI Control Part-------------------------------------------------------------------\\r\\n  // initial\\r\\n  var translation = {tx:45, ty:150, tz:0};\\r\\n  var rotation = {rx:deg_to_rad(40),ry:deg_to_rad(25),rz:deg_to_rad(325)};\\r\\n  var scaling = {sx:1, sy:1, sz:1};\\r\\n  var colors = {r:Math.random(),g: Math.random(),b: Math.random(), a:1};\\r\\n\\r\\n\\r\\n  var transformationObj = {\\r\\n    'translate':translation,\\r\\n    'rotate':rotation,\\r\\n    'scale':scaling,\\r\\n    'colors':colors \\r\\n  };\\r\\n   \\r\\n\\r\\n  const gui = new GUI();\\r\\n  gui.add(document,'title');\\r\\n \\r\\n  const translate = gui.addFolder('Translate');\\r\\n  const rotate = gui.addFolder('Rotate');\\r\\n  const scale = gui.addFolder('Scale');\\r\\n\\r\\n  translate.add(transformationObj.translate,'tx',0,500).onChange(drawScene);\\r\\n  translate.add(transformationObj.translate,'ty',0,500).onChange(drawScene);\\r\\n  translate.add(transformationObj.translate,'tz',0,500).onChange(drawScene);\\r\\n\\r\\n    rotate.add(transformationObj.rotate,'rx',0,360).onChange(drawScene);\\r\\n  rotate.add(transformationObj.rotate,'ry',0,360).onChange(drawScene);\\r\\n  rotate.add(transformationObj.rotate,'rz',0,360).onChange(drawScene);\\r\\n\\r\\n  scale.add(transformationObj.scale,'sx',.1,10).onChange(drawScene);\\r\\n  scale.add(transformationObj.scale,'sy',.1,10).onChange(drawScene);\\r\\n  scale.add(transformationObj.scale,'sz',.1,10).onChange(drawScene);\\r\\n\\r\\n  gui.addColor(transformationObj,'colors').onChange(drawScene);\\r\\n  \\r\\n  //--------------------------------------------------------------------------------------------------------------------------------------\\r\\n\\r\\n  drawScene();\\r\\n  \\r\\n  function drawScene(){\\r\\n    RenderFitToScreen(gl.canvas,window.devicePixelRatio);\\r\\n\\r\\n    // Tell WebGL how to convert from clip space to pixels\\r\\n    gl.viewport(0,0,gl.canvas.width,gl.canvas.height);\\r\\n\\r\\n    //clear the canvas\\r\\n    gl.clearColor(0.05,0.5,0.09,0);\\r\\n    gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);\\r\\n\\r\\n    //tell it to use our program (pair of shaders)\\r\\n    gl.useProgram(program);\\r\\n\\r\\n    //bind the attribute/buffer set we want.\\r\\n    gl.bindVertexArray(vao);\\r\\n\\r\\n  const t = transformationObj.translate;\\r\\n  const r = transformationObj.rotate;\\r\\n  const s = transformationObj.scale;\\r\\n  const c = transformationObj.colors;\\r\\n\\r\\n    //set the color\\r\\n    gl.uniform4f(colorLocation,c.r,c.g,c.b,c.a);\\r\\n\\r\\n    //compute matrix\\r\\n    var matrix = m4.projection(gl.canvas.clientWidth,gl.canvas.clientHeight, 400);\\r\\n    matrix = m4.translate(matrix, t.tx,t.ty,t.tz);\\r\\n   matrix = m4.xRotate(matrix, deg_to_rad(r.rx));\\r\\n    matrix = m4.yRotate(matrix, deg_to_rad(r.ry));\\r\\n    matrix = m4.zRotate(matrix, deg_to_rad(r.rz));\\r\\n    matrix = m4.scale(matrix, s.sx,s.sy,s.sz);\\r\\n     \\r\\n    //set the matrix\\r\\n    gl.uniformMatrix4fv(matrixLocation,false,matrix);\\r\\n\\r\\n    //draw the geometry\\r\\n    var primitiveType = gl.TRIANGLES;\\r\\n    var offset = 0;\\r\\n    var count = 18;\\r\\n    gl.drawArrays(primitiveType, offset, count);\\r\\n  }\\r\\n\\r\\n}\\r\\n\\r\\nmain();\\r\\n\\r\\n\\r\\n\",\n  \"html\": \"<canvas id=\\\"canvas\\\"></canvas>\\r\\n<title>Step 1 - WebGL 3D</title>\\r\\n<script src=\\\"https://cdn.jsdelivr.net/gh/engineer-work/WebGL-lib@f4fff51/shaders/shaderLoader.js\\\"></script>\\r\\n<script src=\\\"https://cdn.jsdelivr.net/gh/engineer-work/WebGL-lib@866810f/render/render_fit_to_screen.js\\\"></script>\\r\\n<script src=\\\"https://cdn.jsdelivr.net/gh/engineer-work/WebGL-lib@49670fb/geometry/english/2d/f.js\\\"></script>\\r\\n<script src=\\\"https://cdn.jsdelivr.net/gh/engineer-work/WebGL-lib@cb01d04/transform/matrix/m4.js\\\"></script>\\r\\n<script src=\\\"https://cdn.jsdelivr.net/npm/lil-gui@0.21\\\"></script>\\r\\n\",\n  \"css\": \" body { margin: 0 }\\n\\ncanvas {\\n  width: 100vw;\\n  height: 100vh;\\n  display: block;\\n}\",\n  \"internal_block_id\": \"ide-941a20b4-7fed-48cd-9622-c1ba84bdb406\"\n}\n```\n\n# Step 2 - 2D 'F' to 3D 'F'\n\n```ide\n{\n  \"js\": \"var vertexShaderSource = `#version 300 es\\r\\n//it will receive data from a buffer\\r\\nin vec4 a_position;\\r\\n\\r\\n//a matrix to transform the position by\\r\\nuniform mat4 u_matrix;\\r\\n\\r\\nvoid main(){\\r\\n gl_Position = u_matrix * a_position;\\r\\n}\\r\\n`;\\r\\nvar fragmentShaderSource = `#version 300 es\\r\\nprecision highp float;\\r\\nuniform vec4 u_color;\\r\\nout vec4 outColor;\\r\\n\\r\\nvoid main(){\\r\\n outColor = u_color;\\r\\n}\\r\\n`;\\r\\n\\r\\nvar GUI = lil.GUI;\\r\\n\\r\\nfunction setGeometry(gl){\\r\\n gl.bufferData(gl.ARRAY_BUFFER,F_3D.positions,gl.STATIC_DRAW);\\r\\n}\\r\\n\\r\\nfunction main(){\\r\\nvar canvas = document.querySelector(\\\"#canvas\\\");\\r\\nvar gl = canvas.getContext(\\\"webgl2\\\");\\r\\nif (!gl) return;\\r\\n\\r\\nvar program = webglUtils.generate(gl,vertexShaderSource,fragmentShaderSource);\\r\\n\\r\\n//look up where the vertex data need to go\\r\\nvar positionAttributeLocation = gl.getAttribLocation(program,\\\"a_position\\\");\\r\\n\\r\\n//look up uniform locations\\r\\nvar colorLocation = gl.getUniformLocation(program, \\\"u_color\\\");\\r\\nvar matrixLocation = gl.getUniformLocation(program,\\\"u_matrix\\\");\\r\\n\\r\\n//create a buffer\\r\\nvar positionBuffer = gl.createBuffer();\\r\\n\\r\\n//create a vertex array object (attribute state)\\r\\nvar vao = gl.createVertexArray();\\r\\n\\r\\n//and make it the one we're currently working with\\r\\ngl. bindVertexArray(vao);\\r\\n\\r\\n//turn on the attribute\\r\\ngl.enableVertexAttribArray(positionAttributeLocation);\\r\\n\\r\\n//Bind it to ARRAY_BUFFER (think of it as ARRAY_BUFFER = positionBuffer)\\r\\ngl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\\r\\n\\r\\n//setGeometry\\r\\nsetGeometry(gl);\\r\\n\\r\\n//tell the attribute how to get data out of positionBuffer (ARRAY_BUFFER)\\r\\nvar size = 3;\\r\\nvar type = gl.FLOAT;\\r\\nvar normalize = false;\\r\\nvar stride = 0;\\r\\nvar offset = 0;\\r\\n\\r\\ngl.vertexAttribPointer(positionAttributeLocation,size,type,normalize,stride,offset);\\r\\n\\r\\n function deg_to_rad(angle){\\r\\n    return angle * (Math.PI/180.0);\\r\\n  }\\r\\n  \\r\\n\\r\\n//------------------------------------------------UI Control Part-------------------------------------------------------------------\\r\\n  // initial\\r\\n  var translation = {tx:45, ty:150, tz:0};\\r\\n  var rotation = {rx:deg_to_rad(40),ry:deg_to_rad(25),rz:deg_to_rad(325)};\\r\\n  var scaling = {sx:1, sy:1, sz:1};\\r\\n  var colors = {r:Math.random(),g: Math.random(),b: Math.random(), a:1};\\r\\n\\r\\n\\r\\n  var transformationObj = {\\r\\n    'translate':translation,\\r\\n    'rotate':rotation,\\r\\n    'scale':scaling,\\r\\n    'colors':colors \\r\\n  };\\r\\n   \\r\\n\\r\\n  const gui = new GUI();\\r\\n  gui.add(document,'title');\\r\\n \\r\\n  const translate = gui.addFolder('Translate');\\r\\n  const rotate = gui.addFolder('Rotate');\\r\\n  const scale = gui.addFolder('Scale');\\r\\n\\r\\n  translate.add(transformationObj.translate,'tx',0,500).onChange(drawScene);\\r\\n  translate.add(transformationObj.translate,'ty',0,500).onChange(drawScene);\\r\\n  translate.add(transformationObj.translate,'tz',0,500).onChange(drawScene);\\r\\n\\r\\n  rotate.add(transformationObj.rotate,'rx',0,360).onChange(drawScene);\\r\\n  rotate.add(transformationObj.rotate,'ry',0,360).onChange(drawScene);\\r\\n  rotate.add(transformationObj.rotate,'rz',0,360).onChange(drawScene);\\r\\n  \\r\\n  scale.add(transformationObj.scale,'sx',.1,10).onChange(drawScene);\\r\\n  scale.add(transformationObj.scale,'sy',.1,10).onChange(drawScene);\\r\\n  scale.add(transformationObj.scale,'sz',.1,10).onChange(drawScene);\\r\\n\\r\\n  gui.addColor(transformationObj,'colors').onChange(drawScene);\\r\\n  \\r\\n  //--------------------------------------------------------------------------------------------------------------------------------------\\r\\n\\r\\n\\r\\n\\r\\ndrawScene();\\r\\n\\r\\nfunction drawScene(){\\r\\n   RenderFitToScreen(gl.canvas,window.devicePixelRatio);\\r\\n\\r\\n   //tell WebGL how to convert from clip space to pixels\\r\\n   gl.viewport(0,0,gl.canvas.width,gl.canvas.height);\\r\\n\\r\\n   //clear the canvas\\r\\n   gl.clearColor(0.1,0.4,0.1,0);\\r\\n   gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\\r\\n   \\r\\n   //tell it to use our program (pair of shaders)\\r\\n   gl.useProgram(program);\\r\\n\\r\\n   //bind the attribute/buffer set we want.\\r\\n   gl.bindVertexArray(vao);\\r\\n\\r\\n    const t = transformationObj.translate;\\r\\n  const r = transformationObj.rotate;\\r\\n  const s = transformationObj.scale;\\r\\n  const c = transformationObj.colors;\\r\\n   \\r\\n   //set the color\\r\\n    gl.uniform4f(colorLocation,c.r,c.g,c.b,c.a);\\r\\n\\r\\n    //compute matrix\\r\\n    var matrix = m4.projection(gl.canvas.clientWidth,gl.canvas.clientHeight, 400);\\r\\n    matrix = m4.translate(matrix, t.tx,t.ty,t.tz);\\r\\n    matrix = m4.xRotate(matrix, deg_to_rad(r.rx));\\r\\n    matrix = m4.yRotate(matrix, deg_to_rad(r.ry));\\r\\n    matrix = m4.zRotate(matrix, deg_to_rad(r.rz));\\r\\n    matrix = m4.scale(matrix, s.sx,s.sy,s.sz);\\r\\n\\r\\n    //set the matrix\\r\\n    gl.uniformMatrix4fv(matrixLocation,false,matrix);\\r\\n\\r\\n   //Draw the geometry\\r\\n   var primitiveType = gl.TRIANGLES;\\r\\n   var offset = 0;\\r\\n   var count = 16*6;\\r\\n   gl.drawArrays(primitiveType, offset, count);\\r\\n\\r\\n}\\r\\n\\r\\n}\\r\\n\\r\\nmain();\",\n  \"html\": \"<canvas id=\\\"canvas\\\"></canvas>\\r\\n<title>Step 2 - 2D 'F' to 3D 'F'</title>\\r\\n<script src=\\\"https://cdn.jsdelivr.net/gh/engineer-work/WebGL-lib@f4fff51/shaders/shaderLoader.js\\\"></script>\\r\\n<script src=\\\"https://cdn.jsdelivr.net/gh/engineer-work/WebGL-lib@866810f/render/render_fit_to_screen.js\\\"></script>\\r\\n<script src=\\\"https://cdn.jsdelivr.net/gh/engineer-work/WebGL-lib@d3882bc/geometry/english/3d/f.js\\\"></script>\\r\\n<script src=\\\"https://cdn.jsdelivr.net/gh/engineer-work/WebGL-lib@cb01d04/transform/matrix/m4.js\\\"></script>\\r\\n<script src=\\\"https://cdn.jsdelivr.net/npm/lil-gui@0.21\\\"></script>\\r\\n\",\n  \"css\": \" body { margin: 0 }\\r\\n\\r\\ncanvas {\\r\\n  width: 100vw;\\r\\n  height: 100vh;\\r\\n  display: block;\\r\\n}\",\n  \"internal_block_id\": \"ide-3c0e56fe-8b4f-4182-bdc6-5410e78edbe1\"\n}\n```\n\n# Step 3 - WebGL\n\n### New Vertex Shader\n```c\n#version 300 es\n \n// an attribute is an input (in) to a vertex shader.\n// It will receive data from a buffer\nin vec4 a_position;\nin vec4 a_color;\n \n// A matrix to transform the positions by\nuniform mat4 u_matrix;\n \n// a varying the color to the fragment shader\nout vec4 v_color;\n \n// all shaders have a main function\nvoid main() {\n  // Multiply the position by the matrix.\n  gl_Position = u_matrix * a_position;\n \n  // Pass the color to the fragment shader.\n  v_color = a_color;\n}\n```\n\n### New Fragment Shader.\n```c\n#version 300 es\n \nprecision highp float;\n \n// the varied color passed from the vertex shader\nin vec4 v_color;\n \n// we need to declare an output for the fragment shader\nout vec4 outColor;\n \nvoid main() {\n  outColor = v_color;\n}\n```\n\n### Attribute location to supply the colors, then setup another buffer and attribute to give it the colors.\n\n```c\n  ...\n  var colorAttributeLocation = gl.getAttribLocation(program, \"a_color\");\n \n  ...\n \n  // create the color buffer, make it the current ARRAY_BUFFER\n  // and copy in the color values\n  var colorBuffer = gl.createBuffer();\n  gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);\n  setColors(gl);\n \n  // Turn on the attribute\n  gl.enableVertexAttribArray(colorAttributeLocation);\n \n  // Tell the attribute how to get data out of colorBuffer (ARRAY_BUFFER)\n  var size = 3;          // 3 components per iteration\n  var type = gl.UNSIGNED_BYTE;   // the data is 8bit unsigned bytes\n  var normalize = true;  // convert from 0-255 to 0.0-1.0\n  var stride = 0;        // 0 = move forward size * sizeof(type) each\n                         // iteration to get the next color\n  var offset = 0;        // start at the beginning of the buffer\n  gl.vertexAttribPointer(\n      colorAttributeLocation, size, type, normalize, stride, offset);\n \n  ...\n \n// Fill the buffer with colors for the 'F'.\n \nfunction setColors(gl) {\n  gl.bufferData(\n      gl.ARRAY_BUFFER,\n      new Uint8Array([\n          // left column front\n        200,  70, 120,\n        200,  70, 120,\n        200,  70, 120,\n        200,  70, 120,\n        200,  70, 120,\n        200,  70, 120,\n \n          // top rung front\n        200,  70, 120,\n        200,  70, 120,\n        ...\n        ...\n      gl.STATIC_DRAW);\n}\n```\n\n### Code for Step 3 - WebGL 3D\n\n![](https://webgl2fundamentals.org/webgl/lessons/resources/triangle-winding.svg)\n\n1. Face with MultiColor\n2. Toggle CULL_FACE\n3. Toggle DEPTH_TEST\n```ide\n{\n  \"js\": \"var vertexShaderSource = `#version 300 es\\r\\n//it will receive data from buffer\\r\\nin vec4 a_position;\\r\\nin vec4 a_color;\\r\\n\\r\\n//A matrix to transform the position by\\r\\nuniform mat4 u_matrix;\\r\\n\\r\\n// a varying the color to the fragment shader\\r\\nout vec4 v_color;\\r\\n\\r\\nvoid main(){\\r\\n  gl_Position = u_matrix * a_position;\\r\\n\\r\\n  //Pass the color to the fragment shader.\\r\\n  v_color = a_color;\\r\\n}\\r\\n`;\\r\\nvar fragmentShaderSource = `#version 300 es\\r\\nprecision highp float;\\r\\n\\r\\n//the varied color passed from the vertex shader\\r\\nin vec4 v_color;\\r\\n\\r\\n//we need to declare an output for the fragment shader\\r\\nout vec4 outColor;\\r\\n\\r\\nvoid main(){\\r\\n outColor = v_color;\\r\\n}\\r\\n`;\\r\\n\\r\\nvar GUI = lil.GUI;\\r\\n\\r\\nfunction setGeometry(gl){\\r\\n  gl.bufferData(gl.ARRAY_BUFFER,FGeometry3D.positions,gl.STATIC_DRAW);\\r\\n}\\r\\n\\r\\nfunction setColors(gl){\\r\\n  gl.bufferData(gl.ARRAY_BUFFER,FGeometry3D.colors,gl.STATIC_DRAW);\\r\\n}\\r\\n\\r\\nfunction main(){\\r\\n  var canvas = document.querySelector(\\\"#canvas\\\");\\r\\n  var gl = canvas.getContext(\\\"webgl2\\\");\\r\\n  if(!gl) return;\\r\\n\\r\\n  var program = webglUtils.generate(gl,vertexShaderSource,fragmentShaderSource);\\r\\n  \\r\\n  //look up where vertex data need to go\\r\\n  var positionAttributeLocation = gl.getAttribLocation(program, \\\"a_position\\\");\\r\\n  var colorAttributeLocation = gl.getAttribLocation(program, \\\"a_color\\\");\\r\\n\\r\\n  //loop up uniform locations\\r\\n  var matrixLocation = gl.getUniformLocation(program, \\\"u_matrix\\\");\\r\\n\\r\\n  //create a buffer\\r\\n  var positionBuffer = gl.createBuffer();\\r\\n\\r\\n  //create a vertex array object (attribute state)\\r\\n  var vao = gl.createVertexArray();\\r\\n\\r\\n  //and make it the one we're currently working with\\r\\n  gl.bindVertexArray(vao);\\r\\n\\r\\n  //turn on the attribute\\r\\n  gl.enableVertexAttribArray(positionAttributeLocation);\\r\\n\\r\\n  //bind it to ARRAY_BUFFER (think of it as ARRAY_BUFFER = positionBuffer)\\r\\n  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\\r\\n\\r\\n  //set geometry\\r\\n  setGeometry(gl);\\r\\n\\r\\n  //tell the attribute how to get data out of positionBuffer (ARRAY_BUFFER\\r\\n  var size = 3;\\r\\n  var type = gl.FLOAT;\\r\\n  var normalize = false;\\r\\n  var stride = 0;\\r\\n  var offset = 0;\\r\\n\\r\\n  gl.vertexAttribPointer(positionAttributeLocation,size,type,normalize,stride,offset);\\r\\n\\r\\n  // create the color buffer, make it the current ARRAY_BUFFER\\r\\n  // and copy in the color values\\r\\n  var colorBuffer = gl.createBuffer();\\r\\n  gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);\\r\\n  gl.enableVertexAttribArray(colorAttributeLocation);\\r\\n\\r\\n  setColors(gl);\\r\\n\\r\\n  //turn on the attribute\\r\\n\\r\\n  //Turn on the attribue\\r\\n  var size1 = 3;\\r\\n  var type1 = gl.UNSIGNED_BYTE;\\r\\n  var normalize1 = true;\\r\\n  var stride1 = 0;\\r\\n  var offset1 =0;\\r\\n\\r\\n  gl.vertexAttribPointer(colorAttributeLocation, size1, type1, normalize1, stride1, offset1);     \\r\\n\\r\\nfunction deg_to_rad(angle){\\r\\n    return angle * (Math.PI/180.0);\\r\\n}\\r\\n\\r\\nfunction rad_to_deg(rad){\\r\\n    return rad * (180.0/Math.PI);\\r\\n}\\r\\n\\r\\n\\r\\n//------------------------------------------------UI Control Part-------------------------------------------------------------------\\r\\n  // initial\\r\\n  var translation = {tx:45, ty:150, tz:0};\\r\\n  var rotation = {rx:deg_to_rad(40),ry:deg_to_rad(25),rz:deg_to_rad(325)};\\r\\n  \\r\\n  //var translation = [-150, 0, -360];\\r\\n  //var translation = {tx:-150, ty:0, tz:-360};\\r\\n  //var rotation = {rx:deg_to_rad(190),ry:deg_to_rad(40),rz:deg_to_rad(30)};\\r\\n  \\r\\n\\r\\n  var scaling = {sx:1, sy:1, sz:1};\\r\\n  var colors = {r:Math.random(),g: Math.random(),b: Math.random(), a:1};\\r\\n\\r\\n  var transformationObj = {\\r\\n    'translate':translation,\\r\\n    'rotate':rotation,\\r\\n    'scale':scaling,\\r\\n    'colors':colors \\r\\n  };\\r\\n\\r\\n  var isfeature = {\\r\\n    'cull_face':false,\\r\\n    'depth_test':false,\\r\\n    'ortho':false,  \\r\\n  }\\r\\n   \\r\\n\\r\\n  const gui = new GUI();\\r\\n  gui.add(document,'title');\\r\\n \\r\\n  const translate = gui.addFolder('Translate');\\r\\n  const rotate = gui.addFolder('Rotate');\\r\\n  const scale = gui.addFolder('Scale');\\r\\n\\r\\n  translate.add(transformationObj.translate,'tx',0,500).onChange(drawScene);\\r\\n  translate.add(transformationObj.translate,'ty',0,500).onChange(drawScene);\\r\\n  translate.add(transformationObj.translate,'tz',0,500).onChange(drawScene);\\r\\n\\r\\n  rotate.add(transformationObj.rotate,'rx',0,360).onChange(drawScene);\\r\\n  rotate.add(transformationObj.rotate,'ry',0,360).onChange(drawScene);\\r\\n  rotate.add(transformationObj.rotate,'rz',0,360).onChange(drawScene);\\r\\n  \\r\\n  scale.add(transformationObj.scale,'sx',.1,10).onChange(drawScene);\\r\\n  scale.add(transformationObj.scale,'sy',.1,10).onChange(drawScene);\\r\\n  scale.add(transformationObj.scale,'sz',.1,10).onChange(drawScene);\\r\\n\\r\\n  gui.addColor(transformationObj,'colors').onChange(drawScene);\\r\\n  \\r\\n  gui.add(isfeature,'cull_face').name('CULL FACE').onChange((v)=>{\\r\\n   if(v){\\r\\n    gl.enable(gl.CULL_FACE);\\r\\n    drawScene();\\r\\n   }else{\\r\\n    gl.disable(gl.CULL_FACE);\\r\\n    drawScene();\\r\\n   }\\r\\n  });\\r\\n\\r\\n\\r\\n   gui.add(isfeature,'depth_test').name('DEPTH TEST').onChange((v)=>{\\r\\n   if(v){\\r\\n    gl.enable(gl.DEPTH_TEST);\\r\\n    drawScene();\\r\\n   }else{\\r\\n    gl.disable(gl.DEPTH_TEST);\\r\\n    drawScene();\\r\\n   }\\r\\n  });\\r\\n\\r\\n//  var matrix;\\r\\n//    gui.add(isfeature,'ortho').name('Orthogonal Projection').onChange((v)=>{\\r\\n//    if(v){\\r\\n//     var left = 0;\\r\\n//     var right = gl.canvas.clientWidth;\\r\\n//     var bottom = gl.canvas.clientHeight; \\r\\n//     var top = 0;\\r\\n//     var near = 200;\\r\\n//    var far = -200;\\r\\n//     matrix = m4.orthographic(left, right, bottom, top, near, far);\\r\\n\\r\\n    \\r\\n//     drawScene();\\r\\n//    }else{\\r\\n\\r\\n// matrix = m4.perspective(fieldOfViewRadians, aspect, zNear, zFar);\\r\\n// var fieldOfViewRadians = deg_to_rad(60);\\r\\n//     var aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;\\r\\n//     var zNear = 1;\\r\\n//     var zFar = 2000;\\r\\n//      matrix = m4.perspective(fieldOfViewRadians, aspect, zNear, zFar);\\r\\n\\r\\n//     drawScene();\\r\\n//    }\\r\\n//   });\\r\\n  \\r\\n\\r\\n  //--------------------------------------------------------------------------------------------------------------------------------------\\r\\n\\r\\n\\r\\n  drawScene();\\r\\n  \\r\\n  function drawScene(){\\r\\n\\r\\n   RenderFitToScreen(gl.canvas,window.devicePixelRatio);\\r\\n   //tell webgl how to convert from clip space to pixel\\r\\n   gl.viewport(0,0,gl.canvas.width,gl.canvas.height);\\r\\n  \\r\\n   gl.clearColor(0.1,0.4,0.2,0.0);\\r\\n   gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\\r\\n   \\r\\n\\r\\n\\r\\n   gl.useProgram(program);\\r\\n\\r\\n   gl.bindVertexArray(vao);\\r\\n\\r\\n   //Matrix\\r\\n   \\r\\n  const t = transformationObj.translate;\\r\\n  const r = transformationObj.rotate;\\r\\n  const s = transformationObj.scale;\\r\\n  const c = transformationObj.colors;\\r\\n   \\r\\n   \\r\\n   //set the color\\r\\n    //gl.uniform4f(colorLocation,c.r,c.g,c.b,c.a);\\r\\n\\r\\n    //compute matrix\\r\\n    var matrix = m4.projection(gl.canvas.clientWidth,gl.canvas.clientHeight, 400);\\r\\n\\r\\n    //  var left = 0;\\r\\n    // var right = gl.canvas.clientWidth;\\r\\n    // var bottom = gl.canvas.clientHeight; \\r\\n    // var top = 0;\\r\\n    // var near = 200;\\r\\n    // var far = -200;\\r\\n    //var matrix = m4.orthographic(left, right, bottom, top, near, far);\\r\\n    // var fieldOfViewRadians = deg_to_rad(60);\\r\\n    // var aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;\\r\\n    // var zNear = 1;\\r\\n    // var zFar = 2000;\\r\\n    // var matrix = m4.perspective(fieldOfViewRadians, aspect, zNear, zFar);\\r\\n     \\r\\n\\r\\n    matrix = m4.translate(matrix, t.tx,t.ty,t.tz);\\r\\n    matrix = m4.xRotate(matrix, deg_to_rad(r.rx));\\r\\n    matrix = m4.yRotate(matrix, deg_to_rad(r.ry));\\r\\n    matrix = m4.zRotate(matrix, deg_to_rad(r.rz));\\r\\n    matrix = m4.scale(matrix, s.sx,s.sy,s.sz);\\r\\n\\r\\n\\r\\n   gl.uniformMatrix4fv(matrixLocation, false, matrix);\\r\\n\\r\\n   //Draw the geometry\\r\\n   var primitiveType = gl.TRIANGLES;\\r\\n   var offset = 0;\\r\\n   var count = 16 * 6;\\r\\n   gl.drawArrays(primitiveType, offset, count);\\r\\n\\r\\n  }\\r\\n\\r\\n \\r\\n\\r\\n}\\r\\n\\r\\nmain();\",\n  \"html\": \"<canvas id=\\\"canvas\\\"></canvas>\\r\\n<title>Step 3 - F with multi color</title>\\r\\n<script src=\\\"https://cdn.jsdelivr.net/gh/engineer-work/WebGL-lib@f4fff51/shaders/shaderLoader.js\\\"></script>\\r\\n<script src=\\\"https://cdn.jsdelivr.net/gh/engineer-work/WebGL-lib@866810f/render/render_fit_to_screen.js\\\"></script>\\r\\n<script src=\\\"https://cdn.jsdelivr.net/gh/engineer-work/WebGL-lib@3ef60f3/geometry/english/3d/f_c.js\\\"></script>\\r\\n<script src=\\\"https://cdn.jsdelivr.net/gh/engineer-work/WebGL-lib@cb01d04/transform/matrix/m4.js\\\"></script>\\r\\n<script src=\\\"https://cdn.jsdelivr.net/npm/lil-gui@0.21\\\"></script>\\r\\n\",\n  \"css\": \" body { margin: 0 }\\r\\n\\r\\ncanvas {\\r\\n  width: 100vw;\\r\\n  height: 100vh;\\r\\n  display: block;\\r\\n}\",\n  \"internal_block_id\": \"ide-1f94fba5-f4df-45a6-a9ab-19fb758b687a\"\n}\n```\n\n\n\n",
      "createdAt": 1768821574669
    },
    {
      "id": "46008438-88aa-442a-8819-8e2caf5253a8",
      "parentId": "8599598d-70cd-4cd8-96a4-102bf8c681fc",
      "name": "2. Perspective 3D",
      "type": "FOLDER",
      "content": "",
      "createdAt": 1768890132559
    },
    {
      "id": "ac888e23-3307-4807-94e5-7bd07bde9b9d",
      "parentId": "46008438-88aa-442a-8819-8e2caf5253a8",
      "name": "perspective",
      "type": "FILE",
      "content": "# WebGL 3D Perspective\n\nwhat is perspective? It's basically the feature that things that are further away appear smaller.\n\n![](https://webglfundamentals.org/webgl/lessons/resources/perspective-example.svg)\n\nLooking at the example above we see that things further away are drawn smaller. Given our current sample one easy way to make it so that things that are **further away appear smaller** would be to **divide the clip space X and Y by Z**.\n\nGiven :  line from (10, 15) to (20,15) it's 10 units long. \n\nIn our current sample it would be drawn 10 pixels long. But if we divide by Z then for\n\n---\nif Z is 1\n\n10 / 1 = 10\n\n20 / 1 = 20\n\nabs(10-20) = 10 it would be 10 pixels long, \n\n---\n\nIf Z is 2 it would be\n\n10 / 2 = 5\n\n20 / 2 = 10\n\nabs(5 - 10) = 5\n\n5 pixels long. \n\n---\n\nAt Z = 3 it would be\n\n10 / 3 = 3.333\n\n20 / 3 = 6.666\n\nabs(3.333 - 6.666) = 3.333\n\n---\n\n- You can see that as Z increases, as it gets further away, we'll end up drawing it smaller.\n\n- If we divide in clip space we might get better results because Z will be a smaller number (-1 to +1). \n\n-  If we add a fudgeFactor to multiply Z before we divide we can adjust how much smaller things get for a given distance.\n\n\nLet's try it. First let's change the vertex shader to divide by Z after we've multiplied it by our \"fudgeFactor\".\n\n```c\n<script id=\"vertex-shader-3d\" type=\"x-shader/x-vertex\">\n...\nuniform float u_fudgeFactor;\n...\nvoid main() {\n  // Multiply the position by the matrix.\n  vec4 position = u_matrix * a_position;\n \n  // Adjust the z to divide by\n  float zToDivideBy = 1.0 + position.z * u_fudgeFactor;\n \n  // Divide x and y by z.\n  gl_Position = vec4(position.xy / zToDivideBy, position.zw);\n}\n</script>\n```\n\n- Note, because Z in clip space goes from -1 to +1.\n- I added 1 to get zToDivideBy to go from 0 to +2 * fudgeFactor\n\nWe also need to update the code to let us set the fudgeFactor.\n\n```c\n ...\n  var fudgeLocation = gl.getUniformLocation(program, \"u_fudgeFactor\");\n \n  ...\n  var fudgeFactor = 1;\n  ...\n  function drawScene() {\n    ...\n    // Set the fudgeFactor\n    gl.uniform1f(fudgeLocation, fudgeFactor);\n \n    // Draw the geometry.\n    var primitiveType = gl.TRIANGLES;\n    var offset = 0;\n    var count = 16 * 6;\n    gl.drawArrays(primitiveType, offset, count);\n```\n\n\n1. For Fudge View \n\nDivide only 'xy' by z values.\n\n```c\ngl_Position = vec4(position.xy/zToDivideBy, position.zw);\n```\n\n2. For Fudge View \n\nDivide only 'xyz' by z values.\n\n```c\n // Divide x, y and z by zToDivideBy\n    gl_Position = vec4(position.xyz,  zToDivideBy);\n\n```\n\nIt turns out WebGL takes the x,y,z,w value we assign to gl_Position in our vertex shader and divides it by w automatically.\n\nWe can prove this very easily by changing the shader and instead of doing the division ourselves, put zToDivideBy in gl_Position.w.\n\n   \n```ide\n{\n  \"js\": \"var vertexShaderSource = `#version 300 es\\r\\n\\r\\n//it will receive data from buffer\\r\\nin vec4 a_position;\\r\\nin vec4 a_color;\\r\\n\\r\\n//A matrix to transform the positions by\\r\\nuniform mat4 u_matrix;\\r\\nuniform float u_fudgefactor;\\r\\n\\r\\n//Varying the color to the fragment shader.\\r\\nout vec4 v_color;\\r\\n\\r\\n\\r\\nvoid main(){\\r\\n    vec4 position = u_matrix * a_position;\\r\\n    \\r\\n    // Adjust the z to divide by\\r\\n    float zToDivideBy = 1.0 + position.z * u_fudgefactor;\\r\\n    \\r\\n    //gl_Position = vec4(position.xy/zToDivideBy, position.zw);\\r\\n\\r\\n    // Divide x, y and z by zToDivideBy\\r\\n    gl_Position = vec4(position.xyz,  zToDivideBy);\\r\\n\\r\\n    v_color = a_color;\\r\\n}\\r\\n\\r\\n`;\\r\\nvar fragmentShaderSource = `#version 300 es\\r\\nprecision highp float;\\r\\n\\r\\nin vec4 v_color;\\r\\n\\r\\nout vec4 outColor;\\r\\n\\r\\nvoid main(){\\r\\n  outColor = v_color;\\r\\n}\\r\\n\\r\\n`;\\r\\n\\r\\nfunction setGeometry(gl){\\r\\n   gl.bufferData(gl.ARRAY_BUFFER,FGeometry3D.positions,gl.STATIC_DRAW);\\r\\n}\\r\\n\\r\\nfunction setColors(gl){\\r\\n   gl.bufferData(gl.ARRAY_BUFFER,FGeometry3D.colors,gl.STATIC_DRAW);\\r\\n}\\r\\n\\r\\nvar GUI = lil.GUI;\\r\\n\\r\\nfunction main(){\\r\\n\\r\\nvar canvas = document.querySelector(\\\"#canvas\\\");\\r\\nvar gl = canvas.getContext(\\\"webgl2\\\");\\r\\nif(!gl) return;\\r\\n\\r\\nvar program = webglUtils.generate(gl,vertexShaderSource,fragmentShaderSource);\\r\\n\\r\\n//lookup the vertex data to send\\r\\n\\r\\nvar positionAttributeLocation = gl.getAttribLocation(program, \\\"a_position\\\");\\r\\nvar colorAttributeLocation = gl.getAttribLocation(program, \\\"a_color\\\");\\r\\n\\r\\n// lookup the uniform data to send\\r\\n\\r\\nvar matrixLocation = gl.getUniformLocation(program,\\\"u_matrix\\\");\\r\\nvar fudgeFactorLocation = gl.getUniformLocation(program,\\\"u_fudgefactor\\\");\\r\\n\\r\\n//create buffer\\r\\n\\r\\nvar positionBuffer = gl.createBuffer();\\r\\n\\r\\n//create vertexArray\\r\\n\\r\\nvar vao = gl.createVertexArray();\\r\\n\\r\\n//bind it\\r\\ngl.bindVertexArray(vao);\\r\\n\\r\\n//turn on the attribute\\r\\ngl.enableVertexAttribArray(positionAttributeLocation);\\r\\n\\r\\ngl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\\r\\n\\r\\nsetGeometry(gl);\\r\\n\\r\\nvar size = 3;\\r\\nvar type = gl.FLOAT;\\r\\nvar normalize = false;\\r\\nvar stride = 0;\\r\\nvar offset = 0;\\r\\n\\r\\ngl.vertexAttribPointer(positionAttributeLocation, size, type, normalize, stride, offset);\\r\\n\\r\\nvar colorBuffer = gl.createBuffer();\\r\\n\\r\\ngl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);\\r\\n\\r\\n\\r\\ngl.enableVertexAttribArray(colorAttributeLocation);\\r\\n\\r\\nsetColors(gl);\\r\\n\\r\\nvar size_c = 3;\\r\\nvar type_c = gl.UNSIGNED_BYTE;\\r\\nvar normalize_c = true;\\r\\nvar stride_c = 0;\\r\\nvar offset_c = 0;\\r\\n\\r\\ngl.vertexAttribPointer(colorAttributeLocation, size_c, type_c, normalize_c, stride_c, offset_c);\\r\\n\\r\\nvar fudgeFactor = 1;\\r\\n\\r\\nfunction deg_to_rad(d) {\\r\\n    return d * Math.PI / 180;\\r\\n}\\r\\n\\r\\n//------------------------------------------------UI Control Part-------------------------------------------------------------------\\r\\n  // initial\\r\\n  var translation = {tx:45, ty:150, tz:0};\\r\\n  var rotation = {rx:deg_to_rad(40),ry:deg_to_rad(25),rz:deg_to_rad(325)};\\r\\n  \\r\\n  //var translation = [-150, 0, -360];\\r\\n  //var translation = {tx:-150, ty:0, tz:-360};\\r\\n  //var rotation = {rx:deg_to_rad(190),ry:deg_to_rad(40),rz:deg_to_rad(30)};\\r\\n  \\r\\n\\r\\n  var scaling = {sx:1, sy:1, sz:1};\\r\\n  var colors = {r:Math.random(),g: Math.random(),b: Math.random(), a:1};\\r\\n\\r\\n  var transformationObj = {\\r\\n    'translate':translation,\\r\\n    'rotate':rotation,\\r\\n    'scale':scaling,\\r\\n    'colors':colors,\\r\\n    'fudge_factor':fudgeFactor \\r\\n  };\\r\\n\\r\\n  var isfeature = {\\r\\n    'cull_face':false,\\r\\n    'depth_test':false,\\r\\n    'ortho':false,  \\r\\n  }\\r\\n   \\r\\n\\r\\n  const gui = new GUI();\\r\\n  gui.add(document,'title');\\r\\n \\r\\n  const translate = gui.addFolder('Translate');\\r\\n  const rotate = gui.addFolder('Rotate');\\r\\n  const scale = gui.addFolder('Scale');\\r\\n\\r\\n  gui.add(transformationObj,'fudge_factor',0,1,.01).name(\\\"Fudge Factor\\\").onChange(drawScene);\\r\\n  \\r\\n  translate.add(transformationObj.translate,'tx',0,500).onChange(drawScene);\\r\\n  translate.add(transformationObj.translate,'ty',0,500).onChange(drawScene);\\r\\n  translate.add(transformationObj.translate,'tz',0,500).onChange(drawScene);\\r\\n\\r\\n  rotate.add(transformationObj.rotate,'rx',0,360).onChange(drawScene);\\r\\n  rotate.add(transformationObj.rotate,'ry',0,360).onChange(drawScene);\\r\\n  rotate.add(transformationObj.rotate,'rz',0,360).onChange(drawScene);\\r\\n  \\r\\n  scale.add(transformationObj.scale,'sx',.1,10).onChange(drawScene);\\r\\n  scale.add(transformationObj.scale,'sy',.1,10).onChange(drawScene);\\r\\n  scale.add(transformationObj.scale,'sz',.1,10).onChange(drawScene);\\r\\n\\r\\n  gui.addColor(transformationObj,'colors').onChange(drawScene);\\r\\n\\r\\n//------\\r\\n\\r\\n\\r\\n\\r\\ndrawScene();\\r\\n\\r\\nfunction drawScene(){\\r\\n\\r\\n    RenderFitToScreen(gl.canvas, window.devicePixelRatio);\\r\\n    // tell webgl convert from clipspace to pixel.\\r\\n    gl.viewport(0,0,gl.canvas.width,gl.canvas.height);\\r\\n\\r\\n    gl.enable(gl.DEPTH_TEST);\\r\\n    gl.enable(gl.CULL_FACE);\\r\\n\\r\\n    gl.clearColor(0.1,0.4,0.1,1.0);\\r\\n    gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);\\r\\n\\r\\n    gl.useProgram(program);\\r\\n\\r\\n    gl.bindVertexArray(vao);\\r\\n   const t = transformationObj.translate;\\r\\n  const r = transformationObj.rotate;\\r\\n  const s = transformationObj.scale;\\r\\n  const c = transformationObj.colors;\\r\\n    \\r\\n \\r\\n   var matrix = m4.projection(gl.canvas.clientWidth, gl.canvas.clientHeight, 400);\\r\\n\\r\\n\\r\\n    matrix = m4.translate(matrix, t.tx,t.ty,t.tz);\\r\\n    matrix = m4.xRotate(matrix, deg_to_rad(r.rx));\\r\\n    matrix = m4.yRotate(matrix, deg_to_rad(r.ry));\\r\\n    matrix = m4.zRotate(matrix, deg_to_rad(r.rz));\\r\\n    matrix = m4.scale(matrix, s.sx,s.sy,s.sz);\\r\\n\\r\\n    gl.uniformMatrix4fv(matrixLocation,false, matrix);\\r\\n\\r\\n    gl.uniform1f(fudgeFactorLocation,transformationObj.fudge_factor);\\r\\n\\r\\n    var primitivie = gl.TRIANGLES;\\r\\n    var offset = 0;\\r\\n    var count = 16*6;\\r\\n    gl.drawArrays(primitivie,offset,count);\\r\\n\\r\\n}\\r\\n\\r\\n}\\r\\n\\r\\nmain();\",\n  \"html\": \"<canvas id=\\\"canvas\\\"></canvas>\\r\\n<title>WebGL 3D - Fugde Factor</title>\\r\\n<script src=\\\"https://cdn.jsdelivr.net/gh/engineer-work/WebGL-lib@f4fff51/shaders/shaderLoader.js\\\"></script>\\r\\n<script src=\\\"https://cdn.jsdelivr.net/gh/engineer-work/WebGL-lib@866810f/render/render_fit_to_screen.js\\\"></script>\\r\\n<script src=\\\"https://cdn.jsdelivr.net/gh/engineer-work/WebGL-lib@3ef60f3/geometry/english/3d/f_c.js\\\"></script>\\r\\n<script src=\\\"https://cdn.jsdelivr.net/gh/engineer-work/WebGL-lib@cb01d04/transform/matrix/m4.js\\\"></script>\\r\\n<script src=\\\"https://cdn.jsdelivr.net/npm/lil-gui@0.21\\\"></script>\\r\\n\",\n  \"css\": \" body { margin: 0 }\\r\\n\\r\\ncanvas {\\r\\n  width: 100vw;\\r\\n  height: 100vh;\\r\\n  display: block;\\r\\n}\",\n  \"internal_block_id\": \"ide-e68412c1-6d4a-471e-80c9-d9944597e9db\"\n}\n```\n\n# Fudge Factor to Matrix\n\nWhy is the fact that WebGL automatically divides by W useful? Because now, using more matrix magic, we can just use yet another matrix to copy z to w.\n\nA Matrix like this\n\n$$\n\\begin{matrix}\n  1 & 0 & 0 & 0 \\\\\n  0 & 1 & 0 & 0 \\\\\n  0 & 0 & 1 & 1 \\\\\n  0 & 0 & 0 & 0 \\\\\n\\end{matrix}\n$$\n\nwill copy z to w. You can look at each of those columns as\n\n```c\nx_out = x_in * 1 + y_in * 0 + z_in * 0 + w_in * 0 ;\ny_out = x_in * 0 + y_in * 1 + z_in * 0 + w_in * 0 ;\nz_out = x_in * 0 + y_in * 0 + z_in * 1 + w_in * 0 ;\nw_out = x_in * 0 + y_in * 0 + z_in * 1 + w_in * 0 ;\n```\n\nwhich when simplified is\n\n```c\nx_out = x_in;\ny_out = y_in;\nz_out = z_in;\nw_out = z_in;\n```\n\nWe can add the plus 1 we had before with this matrix since we know w_in is always 1.0.\n\n$$\n\\begin{matrix}\n  1 & 0 & 0 & 0 \\\\\n  0 & 1 & 0 & 0 \\\\\n  0 & 0 & 1 & 1 \\\\\n  0 & 0 & 0 & 1 \\\\\n\\end{matrix}\n$$\n\n\nthat will change the W calculation to\n\n```c\nx_out = x_in * 1 + y_in * 0 + z_in * 0 + w_in * 0 ;\ny_out = x_in * 0 + y_in * 1 + z_in * 0 + w_in * 0 ;\nz_out = x_in * 0 + y_in * 0 + z_in * 1 + w_in * 0 ;\nw_out = x_in * 0 + y_in * 0 + z_in * 1 + w_in * 1 ;\n```\n\nand since we know w_in = 1.0 then that’s really\n\n```c\nx_out = x_in;\ny_out = y_in;\nz_out = z_in;\nw_out = z_in + 1;\n```\n\nFinally we can work our fudgeFactor back in if the matrix is this\n\n$$\n\\begin{matrix}\n  1 & 0 & 0 & 0 \\\\\n  0 & 1 & 0 & 0 \\\\\n  0 & 0 & 1 & fudgeFactor \\\\\n  0 & 0 & 0 & 1 \\\\\n\\end{matrix}\n$$\n\nwhich means\n\n\n```c\nx_out = x_in * 1 + y_in * 0 + z_in * 0 + w_in * 0 ;\ny_out = x_in * 0 + y_in * 1 + z_in * 0 + w_in * 0 ;\nz_out = x_in * 0 + y_in * 0 + z_in * 1 + w_in * 0 ;\nw_out = x_in * 0 + y_in * 0 + z_in * fudgeFactor + w_in * 1 ;\n```\nand simplified that’s\n\n```c\nx_out = x_in;\ny_out = y_in;\nz_out = z_in;\nw_out = z_in*fudgeFactor + 1;\n```\n\nNext let’s make a function to make our Z → W matrix.\n\n```c\nfunction makeZToWMatrix(fudgeFactor) {\n  return [\n    1, 0, 0, 0,\n    0, 1, 0, 0,\n    0, 0, 1, fudgeFactor,\n    0, 0, 0, 1,\n  ];\n}\n```\n\nand we’ll change the code to use it.\n\n```c\nvar matrix = makeZToWMatrix(fudgeFactor);\n    matrix = m4.multiply(matrix, m4.projection(gl.canvas.clientWidth, gl.canvas.clientHeight, 400));\n```\n\nand note, again, it’s exactly the same.\n\n```ide\n{\n  \"js\": \"var vertexShaderSource = `#version 300 es\\r\\n\\r\\n//it will receive data from buffer\\r\\nin vec4 a_position;\\r\\nin vec4 a_color;\\r\\n\\r\\n//A matrix to transform the positions by\\r\\nuniform mat4 u_matrix;\\r\\nuniform float u_fudgefactor;\\r\\n\\r\\n//Varying the color to the fragment shader.\\r\\nout vec4 v_color;\\r\\n\\r\\n\\r\\nvoid main(){\\r\\n    vec4 position = u_matrix * a_position;\\r\\n    \\r\\n  \\r\\n    gl_Position = position;\\r\\n\\r\\n    v_color = a_color;\\r\\n}\\r\\n\\r\\n`;\\r\\nvar fragmentShaderSource = `#version 300 es\\r\\nprecision highp float;\\r\\n\\r\\nin vec4 v_color;\\r\\n\\r\\nout vec4 outColor;\\r\\n\\r\\nvoid main(){\\r\\n  outColor = v_color;\\r\\n}\\r\\n\\r\\n`;\\r\\n\\r\\nfunction setGeometry(gl){\\r\\n   gl.bufferData(gl.ARRAY_BUFFER,FGeometry3D.positions,gl.STATIC_DRAW);\\r\\n}\\r\\n\\r\\nfunction setColors(gl){\\r\\n   gl.bufferData(gl.ARRAY_BUFFER,FGeometry3D.colors,gl.STATIC_DRAW);\\r\\n}\\r\\n\\r\\nvar GUI = lil.GUI;\\r\\n\\r\\nfunction makeZToWMatrix(fudgeFactor) {\\r\\n  return [\\r\\n    1, 0, 0, 0,\\r\\n    0, 1, 0, 0,\\r\\n    0, 0, 1, fudgeFactor,\\r\\n    0, 0, 0, 1,\\r\\n  ];\\r\\n}\\r\\n\\r\\nfunction main(){\\r\\n\\r\\nvar canvas = document.querySelector(\\\"#canvas\\\");\\r\\nvar gl = canvas.getContext(\\\"webgl2\\\");\\r\\nif(!gl) return;\\r\\n\\r\\nvar program = webglUtils.generate(gl,vertexShaderSource,fragmentShaderSource);\\r\\n\\r\\n//lookup the vertex data to send\\r\\n\\r\\nvar positionAttributeLocation = gl.getAttribLocation(program, \\\"a_position\\\");\\r\\nvar colorAttributeLocation = gl.getAttribLocation(program, \\\"a_color\\\");\\r\\n\\r\\n// lookup the uniform data to send\\r\\n\\r\\nvar matrixLocation = gl.getUniformLocation(program,\\\"u_matrix\\\");\\r\\n//var fudgeFactorLocation = gl.getUniformLocation(program,\\\"u_fudgefactor\\\");\\r\\n\\r\\n//create buffer\\r\\n\\r\\nvar positionBuffer = gl.createBuffer();\\r\\n\\r\\n//create vertexArray\\r\\n\\r\\nvar vao = gl.createVertexArray();\\r\\n\\r\\n//bind it\\r\\ngl.bindVertexArray(vao);\\r\\n\\r\\n//turn on the attribute\\r\\ngl.enableVertexAttribArray(positionAttributeLocation);\\r\\n\\r\\ngl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\\r\\n\\r\\nsetGeometry(gl);\\r\\n\\r\\nvar size = 3;\\r\\nvar type = gl.FLOAT;\\r\\nvar normalize = false;\\r\\nvar stride = 0;\\r\\nvar offset = 0;\\r\\n\\r\\ngl.vertexAttribPointer(positionAttributeLocation, size, type, normalize, stride, offset);\\r\\n\\r\\nvar colorBuffer = gl.createBuffer();\\r\\n\\r\\ngl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);\\r\\n\\r\\n\\r\\ngl.enableVertexAttribArray(colorAttributeLocation);\\r\\n\\r\\nsetColors(gl);\\r\\n\\r\\nvar size_c = 3;\\r\\nvar type_c = gl.UNSIGNED_BYTE;\\r\\nvar normalize_c = true;\\r\\nvar stride_c = 0;\\r\\nvar offset_c = 0;\\r\\n\\r\\ngl.vertexAttribPointer(colorAttributeLocation, size_c, type_c, normalize_c, stride_c, offset_c);\\r\\n\\r\\nvar fudgeFactor = 1;\\r\\n\\r\\nfunction deg_to_rad(d) {\\r\\n    return d * Math.PI / 180;\\r\\n}\\r\\n\\r\\n//------------------------------------------------UI Control Part-------------------------------------------------------------------\\r\\n  // initial\\r\\n  var translation = {tx:45, ty:150, tz:0};\\r\\n  var rotation = {rx:deg_to_rad(40),ry:deg_to_rad(25),rz:deg_to_rad(325)};\\r\\n  \\r\\n  //var translation = [-150, 0, -360];\\r\\n  //var translation = {tx:-150, ty:0, tz:-360};\\r\\n  //var rotation = {rx:deg_to_rad(190),ry:deg_to_rad(40),rz:deg_to_rad(30)};\\r\\n  \\r\\n\\r\\n  var scaling = {sx:1, sy:1, sz:1};\\r\\n  var colors = {r:Math.random(),g: Math.random(),b: Math.random(), a:1};\\r\\n\\r\\n  var transformationObj = {\\r\\n    'translate':translation,\\r\\n    'rotate':rotation,\\r\\n    'scale':scaling,\\r\\n    'colors':colors,\\r\\n    'fudge_factor':fudgeFactor \\r\\n  };\\r\\n\\r\\n  var isfeature = {\\r\\n    'cull_face':false,\\r\\n    'depth_test':false,\\r\\n    'ortho':false,  \\r\\n  }\\r\\n   \\r\\n\\r\\n  const gui = new GUI();\\r\\n  gui.add(document,'title');\\r\\n \\r\\n  const translate = gui.addFolder('Translate');\\r\\n  const rotate = gui.addFolder('Rotate');\\r\\n  const scale = gui.addFolder('Scale');\\r\\n\\r\\n  gui.add(transformationObj,'fudge_factor',0,1,.01).name(\\\"Fudge Factor\\\").onChange(drawScene);\\r\\n  \\r\\n  translate.add(transformationObj.translate,'tx',0,500).onChange(drawScene);\\r\\n  translate.add(transformationObj.translate,'ty',0,500).onChange(drawScene);\\r\\n  translate.add(transformationObj.translate,'tz',0,500).onChange(drawScene);\\r\\n\\r\\n  rotate.add(transformationObj.rotate,'rx',0,360).onChange(drawScene);\\r\\n  rotate.add(transformationObj.rotate,'ry',0,360).onChange(drawScene);\\r\\n  rotate.add(transformationObj.rotate,'rz',0,360).onChange(drawScene);\\r\\n  \\r\\n  scale.add(transformationObj.scale,'sx',.1,10).onChange(drawScene);\\r\\n  scale.add(transformationObj.scale,'sy',.1,10).onChange(drawScene);\\r\\n  scale.add(transformationObj.scale,'sz',.1,10).onChange(drawScene);\\r\\n\\r\\n  gui.addColor(transformationObj,'colors').onChange(drawScene);\\r\\n\\r\\n//------\\r\\n\\r\\n\\r\\n\\r\\ndrawScene();\\r\\n\\r\\nfunction drawScene(){\\r\\n\\r\\n    RenderFitToScreen(gl.canvas, window.devicePixelRatio);\\r\\n    // tell webgl convert from clipspace to pixel.\\r\\n    gl.viewport(0,0,gl.canvas.width,gl.canvas.height);\\r\\n\\r\\n    gl.enable(gl.DEPTH_TEST);\\r\\n    gl.enable(gl.CULL_FACE);\\r\\n\\r\\n    gl.clearColor(0.1,0.4,0.1,1.0);\\r\\n    gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);\\r\\n\\r\\n    gl.useProgram(program);\\r\\n\\r\\n    gl.bindVertexArray(vao);\\r\\n   const t = transformationObj.translate;\\r\\n  const r = transformationObj.rotate;\\r\\n  const s = transformationObj.scale;\\r\\n  const c = transformationObj.colors;\\r\\n    \\r\\n \\r\\n    var matrix = makeZToWMatrix(transformationObj.fudge_factor);\\r\\n    matrix = m4.multiply(matrix, m4.projection(gl.canvas.clientWidth, gl.canvas.clientHeight, 400));\\r\\n\\r\\n    matrix = m4.translate(matrix, t.tx,t.ty,t.tz);\\r\\n    matrix = m4.xRotate(matrix, deg_to_rad(r.rx));\\r\\n    matrix = m4.yRotate(matrix, deg_to_rad(r.ry));\\r\\n    matrix = m4.zRotate(matrix, deg_to_rad(r.rz));\\r\\n    matrix = m4.scale(matrix, s.sx,s.sy,s.sz);\\r\\n\\r\\n    gl.uniformMatrix4fv(matrixLocation,false, matrix);\\r\\n\\r\\n    //gl.uniform1f(fudgeFactorLocation,transformationObj.fudge_factor);\\r\\n\\r\\n    var primitivie = gl.TRIANGLES;\\r\\n    var offset = 0;\\r\\n    var count = 16*6;\\r\\n    gl.drawArrays(primitivie,offset,count);\\r\\n\\r\\n}\\r\\n\\r\\n}\\r\\n\\r\\nmain();\",\n  \"html\": \" <canvas id=\\\"canvas\\\"></canvas>\\r\\n<title>Fugde Factor to Matrix</title>\\r\\n<script src=\\\"https://cdn.jsdelivr.net/gh/engineer-work/WebGL-lib@f4fff51/shaders/shaderLoader.js\\\"></script>\\r\\n<script src=\\\"https://cdn.jsdelivr.net/gh/engineer-work/WebGL-lib@866810f/render/render_fit_to_screen.js\\\"></script>\\r\\n<script src=\\\"https://cdn.jsdelivr.net/gh/engineer-work/WebGL-lib@3ef60f3/geometry/english/3d/f_c.js\\\"></script>\\r\\n<script src=\\\"https://cdn.jsdelivr.net/gh/engineer-work/WebGL-lib@cb01d04/transform/matrix/m4.js\\\"></script>\\r\\n<script src=\\\"https://cdn.jsdelivr.net/npm/lil-gui@0.21\\\"></script>\\r\\n  \",\n  \"css\": \" body { margin: 0 }\\r\\n\\r\\ncanvas {\\r\\n  width: 100vw;\\r\\n  height: 100vh;\\r\\n  display: block;\\r\\n}\",\n  \"internal_block_id\": \"ide-b20aaf2f-f5ac-486e-883b-00329cda241b\"\n}\n```\n\n# FudgeFactor to FieldOfView\n\nAll that was basically just to show you that dividing by Z gives us perspective and that WebGL conveniently does this divide by Z for us.\n\nBut there are still some problems. For example if you set Z to around -100 you’ll see something like the animation below\n\n![](https://webgl2fundamentals.org/webgl/lessons/resources/z-clipping.gif)\n\nWhat’s going on? Why is the F disappearing early? Just like WebGL clips X and Y to values between +1 to -1 it also clips Z. What we’re seeing here is where Z < -1.\n\nI could go into detail about the math to fix it but [you can derive it](https://stackoverflow.com/questions/28286057/trying-to-understand-the-math-behind-the-perspective-matrix-in-webgl/28301213#28301213) the same way we did 2D projection. We need to take Z, add some amount and scale some amount and we can make any range we want get remapped to the -1 to +1.\n\nHere’s a function to build the matrix.\n\n```c\nvar m4 = {\n  perspective: function(fieldOfViewInRadians, aspect, near, far) {\n    var f = Math.tan(Math.PI * 0.5 - 0.5 * fieldOfViewInRadians);\n    var rangeInv = 1.0 / (near - far);\n \n    return [\n      f / aspect, 0, 0, 0,\n      0, f, 0, 0,\n      0, 0, (near + far) * rangeInv, -1,\n      0, 0, near * far * rangeInv * 2, 0\n    ];\n  },\n \n  ...\n```\n\n- This matrix will do all our conversions for us.\n- It will adjust the units so they are in clip space, it will do the math so that we can choose a field of view by angle and it will let us choose our Z-clipping space.\n- It assumes there’s an eye or camera at the origin (0, 0, 0) and given a zNear and a fieldOfView it computes what it would take so that stuff at zNear ends up at Z = -1 and stuff at zNear that is half of fieldOfView above or below the center ends up with Y = -1 and Y = 1 respectively. \n- It computes what to use for X by just multiplying by the aspect passed in. \n- We’d normally set this to the width / height of the display area. \n- Finally, it figures out how much to scale things in Z so that stuff at zFar ends up at Z = 1.\n\n\nThere’s just one problem left. This matrix assumes there’s a viewer at 0,0,0 and it assumes it’s looking in the negative Z direction and that positive Y is up. Our matrices up to this point have done things in a different way.\n\nTo make it appear we need to move it inside the frustum. We can do that by moving our F. We were drawing at (45, 150, 0). Let’s move it to (-150, 0, -360) and let’s set the rotation to something that makes it appear right side up.\n\n```ide\n{\n  \"js\": \"var vertexShaderSource = `#version 300 es\\r\\n\\r\\n//it will receive data from buffer\\r\\nin vec4 a_position;\\r\\nin vec4 a_color;\\r\\n\\r\\n//A matrix to transform the positions by\\r\\nuniform mat4 u_matrix;\\r\\nuniform float u_fudgefactor;\\r\\n\\r\\n//Varying the color to the fragment shader.\\r\\nout vec4 v_color;\\r\\n\\r\\n\\r\\nvoid main(){\\r\\n    vec4 position = u_matrix * a_position;\\r\\n    \\r\\n  \\r\\n    gl_Position = position;\\r\\n\\r\\n    v_color = a_color;\\r\\n}\\r\\n\\r\\n`;\\r\\nvar fragmentShaderSource = `#version 300 es\\r\\nprecision highp float;\\r\\n\\r\\nin vec4 v_color;\\r\\n\\r\\nout vec4 outColor;\\r\\n\\r\\nvoid main(){\\r\\n  outColor = v_color;\\r\\n}\\r\\n\\r\\n`;\\r\\n\\r\\nfunction setGeometry(gl){\\r\\n   gl.bufferData(gl.ARRAY_BUFFER,FGeometry3D.positions,gl.STATIC_DRAW);\\r\\n}\\r\\n\\r\\nfunction setColors(gl){\\r\\n   gl.bufferData(gl.ARRAY_BUFFER,FGeometry3D.colors,gl.STATIC_DRAW);\\r\\n}\\r\\n\\r\\nvar GUI = lil.GUI;\\r\\n\\r\\n\\r\\nfunction main(){\\r\\n\\r\\nvar canvas = document.querySelector(\\\"#canvas\\\");\\r\\nvar gl = canvas.getContext(\\\"webgl2\\\");\\r\\nif(!gl) return;\\r\\n\\r\\nvar program = webglUtils.generate(gl,vertexShaderSource,fragmentShaderSource);\\r\\n\\r\\n//lookup the vertex data to send\\r\\n\\r\\nvar positionAttributeLocation = gl.getAttribLocation(program, \\\"a_position\\\");\\r\\nvar colorAttributeLocation = gl.getAttribLocation(program, \\\"a_color\\\");\\r\\n\\r\\n// lookup the uniform data to send\\r\\n\\r\\nvar matrixLocation = gl.getUniformLocation(program,\\\"u_matrix\\\");\\r\\n\\r\\n//create buffer\\r\\n\\r\\nvar positionBuffer = gl.createBuffer();\\r\\n\\r\\n//create vertexArray\\r\\n\\r\\nvar vao = gl.createVertexArray();\\r\\n\\r\\n//bind it\\r\\ngl.bindVertexArray(vao);\\r\\n\\r\\n//turn on the attribute\\r\\ngl.enableVertexAttribArray(positionAttributeLocation);\\r\\n\\r\\ngl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\\r\\n\\r\\nsetGeometry(gl);\\r\\n\\r\\nvar size = 3;\\r\\nvar type = gl.FLOAT;\\r\\nvar normalize = false;\\r\\nvar stride = 0;\\r\\nvar offset = 0;\\r\\n\\r\\ngl.vertexAttribPointer(positionAttributeLocation, size, type, normalize, stride, offset);\\r\\n\\r\\nvar colorBuffer = gl.createBuffer();\\r\\n\\r\\ngl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);\\r\\n\\r\\n\\r\\ngl.enableVertexAttribArray(colorAttributeLocation);\\r\\n\\r\\nsetColors(gl);\\r\\n\\r\\nvar size_c = 3;\\r\\nvar type_c = gl.UNSIGNED_BYTE;\\r\\nvar normalize_c = true;\\r\\nvar stride_c = 0;\\r\\nvar offset_c = 0;\\r\\n\\r\\ngl.vertexAttribPointer(colorAttributeLocation, size_c, type_c, normalize_c, stride_c, offset_c);\\r\\n\\r\\nvar fudgeFactor = 1;\\r\\n\\r\\nfunction deg_to_rad(d) {\\r\\n    return d * Math.PI / 180;\\r\\n}\\r\\n\\r\\n//------------------------------------------------UI Control Part-------------------------------------------------------------------\\r\\n  // initial\\r\\n  //var translation = {tx:45, ty:150, tz:0};\\r\\n  //var rotation = {rx:deg_to_rad(40),ry:deg_to_rad(25),rz:deg_to_rad(325)};\\r\\n  \\r\\n  var translation = {tx:-150, ty:0, tz:-360};\\r\\n  var rotation = {rx:deg_to_rad(190),ry:deg_to_rad(40),rz:deg_to_rad(30)};\\r\\n  var fov = 45;\\r\\n\\r\\n  var scaling = {sx:1, sy:1, sz:1};\\r\\n  var colors = {r:Math.random(),g: Math.random(),b: Math.random(), a:1};\\r\\n\\r\\n  var transformationObj = {\\r\\n    'translate':translation,\\r\\n    'rotate':rotation,\\r\\n    'scale':scaling,\\r\\n    'colors':colors,\\r\\n    'fov':fov \\r\\n  };\\r\\n\\r\\n  \\r\\n   \\r\\n\\r\\n  const gui = new GUI();\\r\\n  gui.add(document,'title');\\r\\n \\r\\n  const translate = gui.addFolder('Translate');\\r\\n  const rotate = gui.addFolder('Rotate');\\r\\n  const scale = gui.addFolder('Scale');\\r\\n  const r = 1000;\\r\\n\\r\\n  gui.add(transformationObj,'fov',1,60).name(\\\"Field of View\\\").onChange(drawScene);\\r\\n  \\r\\n  translate.add(transformationObj.translate,'tx',-r,r).onChange(drawScene);\\r\\n  translate.add(transformationObj.translate,'ty',-r,r).onChange(drawScene);\\r\\n  translate.add(transformationObj.translate,'tz',-2000,-200).onChange(drawScene);\\r\\n\\r\\n  rotate.add(transformationObj.rotate,'rx',0,360).onChange(drawScene);\\r\\n  rotate.add(transformationObj.rotate,'ry',0,360).onChange(drawScene);\\r\\n  rotate.add(transformationObj.rotate,'rz',0,360).onChange(drawScene);\\r\\n  \\r\\n  scale.add(transformationObj.scale,'sx',.1,10).onChange(drawScene);\\r\\n  scale.add(transformationObj.scale,'sy',.1,10).onChange(drawScene);\\r\\n  scale.add(transformationObj.scale,'sz',.1,10).onChange(drawScene);\\r\\n\\r\\n  gui.addColor(transformationObj,'colors').onChange(drawScene);\\r\\n\\r\\n//------\\r\\n\\r\\n\\r\\n\\r\\ndrawScene();\\r\\n\\r\\nfunction drawScene(){\\r\\n\\r\\n    RenderFitToScreen(gl.canvas, window.devicePixelRatio);\\r\\n    // tell webgl convert from clipspace to pixel.\\r\\n    gl.viewport(0,0,gl.canvas.width,gl.canvas.height);\\r\\n\\r\\n    gl.enable(gl.DEPTH_TEST);\\r\\n    gl.enable(gl.CULL_FACE);\\r\\n\\r\\n    gl.clearColor(0.1,0.4,0.1,1.0);\\r\\n    gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);\\r\\n\\r\\n    gl.useProgram(program);\\r\\n\\r\\n    gl.bindVertexArray(vao);\\r\\n   const t = transformationObj.translate;\\r\\n  const r = transformationObj.rotate;\\r\\n  const s = transformationObj.scale;\\r\\n  const c = transformationObj.colors;\\r\\n    \\r\\n \\r\\n    var aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;\\r\\n    var zNear = 1;\\r\\n    var zFar = 2000;\\r\\n    var matrix = m4.perspective(deg_to_rad(transformationObj.fov), aspect, zNear, zFar);\\r\\n    \\r\\n    matrix = m4.translate(matrix, t.tx,t.ty,t.tz);\\r\\n    matrix = m4.xRotate(matrix, deg_to_rad(r.rx));\\r\\n    matrix = m4.yRotate(matrix, deg_to_rad(r.ry));\\r\\n    matrix = m4.zRotate(matrix, deg_to_rad(r.rz));\\r\\n    matrix = m4.scale(matrix, s.sx,s.sy,s.sz);\\r\\n\\r\\n    gl.uniformMatrix4fv(matrixLocation,false, matrix);\\r\\n\\r\\n\\r\\n\\r\\n    var primitivie = gl.TRIANGLES;\\r\\n    var offset = 0;\\r\\n    var count = 16*6;\\r\\n    gl.drawArrays(primitivie,offset,count);\\r\\n\\r\\n}\\r\\n\\r\\n}\\r\\n\\r\\nmain();\",\n  \"html\": \"<canvas id=\\\"canvas\\\"></canvas>\\r\\n<title>Perspective - Field of View</title>\\r\\n<script src=\\\"https://cdn.jsdelivr.net/gh/engineer-work/WebGL-lib@f4fff51/shaders/shaderLoader.js\\\"></script>\\r\\n<script src=\\\"https://cdn.jsdelivr.net/gh/engineer-work/WebGL-lib@866810f/render/render_fit_to_screen.js\\\"></script>\\r\\n<script src=\\\"https://cdn.jsdelivr.net/gh/engineer-work/WebGL-lib@3ef60f3/geometry/english/3d/f_c.js\\\"></script>\\r\\n<script src=\\\"https://cdn.jsdelivr.net/gh/engineer-work/WebGL-lib@cb01d04/transform/matrix/m4.js\\\"></script>\\r\\n<script src=\\\"https://cdn.jsdelivr.net/npm/lil-gui@0.21\\\"></script>\\r\\n\",\n  \"css\": \" body { margin: 0 }\\r\\n\\r\\ncanvas {\\r\\n  width: 100vw;\\r\\n  height: 100vh;\\r\\n  display: block;\\r\\n}\",\n  \"internal_block_id\": \"ide-c7e91b0b-23b7-41f8-bb29-8a48434a974c\"\n}\n```\n\n\n",
      "createdAt": 1768890134016
    },
    {
      "id": "471cc659-9553-4a51-827a-0409437335ea",
      "parentId": "8599598d-70cd-4cd8-96a4-102bf8c681fc",
      "name": "3. Visualizing the Camera",
      "type": "FOLDER",
      "content": "",
      "createdAt": 1768974601750
    },
    {
      "id": "26197ad8-9140-410c-87e2-eb5541dcf0a4",
      "parentId": "471cc659-9553-4a51-827a-0409437335ea",
      "name": "visualizing camera",
      "type": "FILE",
      "content": "# Visualizing the Camera\n\n- It’s often useful to be able to visualize what a camera sees, it’s “frustum”. This is surprisingly easy.\n- As pointed in the articles on orthographic and perspective projection those projection matrices take some space and convert them into the -1 to +1 box of clip space. \n- Further a camera matrix is just a matrix that represents some place and orientation in world space of the camera.\n\n- So, the first thing that should be kind of obvious. If we just use the camera matrix to draw something we’ll have an object representing the camera. \n\n- The complication is that a camera can’t see itself, but, using the techniques from the article on multiple views we can have 2 views. \n\n- We’ll use a different camera in each view. The 2nd view will look at the first and so will see be able to see this object we’re drawing to represent the camera used in the other view.\n\n- First let’s make some data to represent the camera. Let’s make a cube and then let’s add a cone to the end. We’re going to draw this with lines.\n\n-  We’ll use indices to connect the vertices.\n\n- Cameras view down the -Z direction so let’s put the cube and cone on the positive side with the cone opening toward -Z\n\n# Camera and Projection controller.\n  1. Camera controller.\n  2. Perspective projection controller.\n  3. Orthogonal projection controller.\n  \n\n```ide\n{\n  \"js\": \"var vertexShaderSource = `#version 300 es\\r\\n\\r\\n//it will receive data from buffer\\r\\nin vec4 a_position;\\r\\nin vec4 a_color;\\r\\n\\r\\n//A matrix to transform the positions by\\r\\nuniform mat4 u_matrix;\\r\\n\\r\\n//Varying the color to the fragment shader.\\r\\nout vec4 v_color;\\r\\n\\r\\n\\r\\nvoid main(){\\r\\n    vec4 position = u_matrix * a_position;\\r\\n    \\r\\n  \\r\\n    gl_Position = position;\\r\\n\\r\\n    v_color = a_color;\\r\\n}\\r\\n\\r\\n`;\\r\\nvar fragmentShaderSource = `#version 300 es\\r\\nprecision highp float;\\r\\n\\r\\nin vec4 v_color;\\r\\n\\r\\nout vec4 outColor;\\r\\n\\r\\nvoid main(){\\r\\n  outColor = v_color;\\r\\n}\\r\\n\\r\\n`;\\r\\n\\r\\n//------------only for camera object-------\\r\\n\\r\\nconst colorVS = `#version 300 es\\r\\nin vec4 a_position;\\r\\n\\r\\nuniform mat4 u_matrix;\\r\\n\\r\\nvoid main() {\\r\\n  // Multiply the position by the matrix.\\r\\n  gl_Position = u_matrix * a_position;\\r\\n}\\r\\n`;\\r\\n\\r\\nconst colorFS = `#version 300 es\\r\\nprecision highp float;\\r\\n\\r\\nuniform vec4 u_color;\\r\\n\\r\\nout vec4 outColor;\\r\\n\\r\\nvoid main() {\\r\\n  outColor = u_color;\\r\\n}\\r\\n`;\\r\\n\\r\\n//-----------------------------------------\\r\\n\\r\\n\\r\\nfunction setGeometry(gl){\\r\\n   gl.bufferData(gl.ARRAY_BUFFER,FGeometry3D.positions,gl.STATIC_DRAW);\\r\\n}\\r\\n\\r\\nfunction setColors(gl){\\r\\n   gl.bufferData(gl.ARRAY_BUFFER,FGeometry3D.colors,gl.STATIC_DRAW);\\r\\n}\\r\\n\\r\\nvar GUI = lil.GUI;\\r\\n\\r\\nfunction object_f(gl,positionAttributeLocation, colorAttributeLocation )\\r\\n{\\r\\n  var positionBuffer = gl.createBuffer();\\r\\n  var vao = gl.createVertexArray();\\r\\n  gl.bindVertexArray(vao);\\r\\n  gl.enableVertexAttribArray(positionAttributeLocation);\\r\\n  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\\r\\n  setGeometry(gl);\\r\\n\\r\\n  var size = 3;\\r\\n  var type = gl.FLOAT;\\r\\n  var normalize = false;\\r\\n  var stride = 0;\\r\\n  var offset = 0;\\r\\n  gl.vertexAttribPointer(positionAttributeLocation, size, type, normalize, stride, offset);\\r\\n\\r\\n  var colorBuffer = gl.createBuffer();\\r\\n\\r\\n  gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);\\r\\n  gl.enableVertexAttribArray(colorAttributeLocation);\\r\\n\\r\\n  setColors(gl);\\r\\n\\r\\n  var size_c = 3;\\r\\n  var type_c = gl.UNSIGNED_BYTE;\\r\\n  var normalize_c = true;\\r\\n  var stride_c = 0;\\r\\n  var offset_c = 0;\\r\\n\\r\\n  gl.vertexAttribPointer(colorAttributeLocation, size_c, type_c, normalize_c, stride_c, offset_c);\\r\\n\\r\\n  return vao;\\r\\n\\r\\n\\r\\n}\\r\\n\\r\\n\\r\\nfunction object_camera_ctrl(gl, positionAttributeLocation) \\r\\n{\\r\\n\\r\\n  const positions = [\\r\\n    -1, -1,  1,\\r\\n     1, -1,  1,\\r\\n    -1,  1,  1,\\r\\n     1,  1,  1,\\r\\n    -1, -1,  3,\\r\\n     1, -1,  3,\\r\\n    -1,  1,  3,\\r\\n     1,  1,  3,\\r\\n     0,  0,  1,\\r\\n  ];\\r\\n\\r\\n  const indices = [\\r\\n    0, 1, 1, 3, 3, 2, 2, 0,\\r\\n    4, 5, 5, 7, 7, 6, 6, 4,\\r\\n    0, 4, 1, 5, 3, 7, 2, 6,\\r\\n  ];\\r\\n\\r\\n  for (let i = 0; i < positions.length; i++) {\\r\\n    positions[i] *= 20;\\r\\n  }\\r\\n  \\r\\n  const vao = gl.createVertexArray();\\r\\n  gl.bindVertexArray(vao);\\r\\n\\r\\n  // ---- position buffer ----\\r\\n  const positionBuffer = gl.createBuffer();\\r\\n  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\\r\\n  gl.bufferData(\\r\\n    gl.ARRAY_BUFFER,\\r\\n    new Float32Array(positions),\\r\\n    gl.STATIC_DRAW\\r\\n  );\\r\\n\\r\\n  gl.enableVertexAttribArray(positionAttributeLocation);\\r\\n  gl.vertexAttribPointer(\\r\\n    positionAttributeLocation,\\r\\n    3,\\r\\n    gl.FLOAT,\\r\\n    false,\\r\\n    0,\\r\\n    0\\r\\n  );\\r\\n\\r\\n  // ---- index buffer ----\\r\\n  const indexBuffer = gl.createBuffer();\\r\\n  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);\\r\\n  gl.bufferData(\\r\\n    gl.ELEMENT_ARRAY_BUFFER,\\r\\n    new Uint16Array(indices),\\r\\n    gl.STATIC_DRAW\\r\\n  );\\r\\n\\r\\n  gl.bindVertexArray(vao);\\r\\n\\r\\n  return {\\r\\n    vao,\\r\\n    indexCount: indices.length\\r\\n  };\\r\\n}\\r\\n\\r\\nfunction object_perspective_ctrl(gl,positionAttributeLocation){\\r\\n  const positions = [\\r\\n      -1, -1, -1,  // cube vertices\\r\\n       1, -1, -1,\\r\\n      -1,  1, -1,\\r\\n       1,  1, -1,\\r\\n      -1, -1,  1,\\r\\n       1, -1,  1,\\r\\n      -1,  1,  1,\\r\\n       1,  1,  1,\\r\\n    ];\\r\\n    const indices = [\\r\\n      0, 1, 1, 3, 3, 2, 2, 0, // cube indices\\r\\n      4, 5, 5, 7, 7, 6, 6, 4,\\r\\n      0, 4, 1, 5, 3, 7, 2, 6,\\r\\n    ];\\r\\n\\r\\n  \\r\\n  const vao = gl.createVertexArray();\\r\\n  gl.bindVertexArray(vao);\\r\\n\\r\\n    // ---- position buffer ----\\r\\n  const positionBuffer = gl.createBuffer();\\r\\n  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\\r\\n  gl.bufferData(\\r\\n    gl.ARRAY_BUFFER,\\r\\n    new Float32Array(positions),\\r\\n    gl.STATIC_DRAW\\r\\n  );\\r\\n\\r\\n  gl.enableVertexAttribArray(positionAttributeLocation);\\r\\n  gl.vertexAttribPointer(\\r\\n    positionAttributeLocation,\\r\\n    3,\\r\\n    gl.FLOAT,\\r\\n    false,\\r\\n    0,\\r\\n    0\\r\\n  );\\r\\n\\r\\n  // ---- index buffer ----\\r\\n  const indexBuffer = gl.createBuffer();\\r\\n  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);\\r\\n  gl.bufferData(\\r\\n    gl.ELEMENT_ARRAY_BUFFER,\\r\\n    new Uint16Array(indices),\\r\\n    gl.STATIC_DRAW\\r\\n  );\\r\\n\\r\\n  gl.bindVertexArray(vao);\\r\\n\\r\\n  return {\\r\\n    vao,\\r\\n    indexCount: indices.length\\r\\n  };\\r\\n\\r\\n}\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\nfunction main(){\\r\\n\\r\\n\\r\\n\\r\\nvar canvas = document.querySelector(\\\"#canvas\\\");\\r\\nvar gl = canvas.getContext(\\\"webgl2\\\");\\r\\nif(!gl) return;\\r\\n\\r\\n//----------------------Object F-----------------------------------------------\\r\\nvar program = webglUtils.generate(gl,vertexShaderSource,fragmentShaderSource);\\r\\n//lookup the vertex data to send\\r\\nvar positionAttributeLocation = gl.getAttribLocation(program, \\\"a_position\\\");\\r\\nvar colorAttributeLocation = gl.getAttribLocation(program, \\\"a_color\\\");\\r\\n// lookup the uniform data to send\\r\\nvar matrixLocation = gl.getUniformLocation(program,\\\"u_matrix\\\");\\r\\nvar vao = object_f(gl,positionAttributeLocation, colorAttributeLocation);\\r\\n//----------------------------------------------------------------------------\\r\\nvar camera_ctrl_program = webglUtils.generate(gl,colorVS,colorFS);\\r\\nvar camera_ctrl_positionAttributeLocation = gl.getAttribLocation(camera_ctrl_program, \\\"a_position\\\");\\r\\nvar camera_ctrl_colorAttributeLocation = gl.getUniformLocation(camera_ctrl_program, \\\"u_color\\\");\\r\\nvar camera_ctrl_matrixUniformLocation = gl.getUniformLocation(camera_ctrl_program, \\\"u_matrix\\\");\\r\\nvar camera_vao = object_camera_ctrl(gl,camera_ctrl_positionAttributeLocation);\\r\\nvar perspective_vao = object_perspective_ctrl(gl,camera_ctrl_positionAttributeLocation);\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\nfunction deg_to_rad(d) {\\r\\n    return d * Math.PI / 180;\\r\\n}\\r\\n\\r\\n//------------------------------------------------UI Control Part-------------------------------------------------------------------\\r\\n  // initial\\r\\n  //var translation = {tx:45, ty:150, tz:0};\\r\\n  //var rotation = {rx:deg_to_rad(40),ry:deg_to_rad(25),rz:deg_to_rad(325)};\\r\\n  \\r\\n  var translation = {tx:-35, ty:-75, tz:5};\\r\\n  var rotation = {rx:deg_to_rad(190),ry:deg_to_rad(40),rz:deg_to_rad(30)};\\r\\n  var fov = 45;\\r\\n\\r\\n  var scaling = {sx:1, sy:1, sz:1};\\r\\n  var colors = {r:Math.random(),g: Math.random(),b: Math.random(), a:1};\\r\\n  var camera_position = {x:0, y:0, z:-200};\\r\\n  var isDragging = true;\\r\\n\\r\\n  var zNear = 1;\\r\\n  var zFar = 2000;\\r\\n  var isOrthographicProject = false;\\r\\n  var orthographicUnit = 120;\\r\\n\\r\\n  var transformationObj = {\\r\\n    'translate':translation,\\r\\n    'rotate':rotation,\\r\\n    'scale':scaling,\\r\\n    'colors':colors,\\r\\n    'fov':fov ,\\r\\n    'camera_position': camera_position,\\r\\n    'ui_drag':isDragging,\\r\\n    'near':zNear,\\r\\n    'far':zFar,\\r\\n    'isOrtho':isOrthographicProject,\\r\\n    'orthoUnit':orthographicUnit\\r\\n  };\\r\\n\\r\\n  \\r\\n //------------------------------------------------  \\r\\n\\r\\n  const gui = new GUI();\\r\\n // gui.domElement = gui.domElement || gui.__ul.parentElement;\\r\\n\\r\\n  gui.add(document,'title');\\r\\n  gui.add(transformationObj,'fov',1,60).name(\\\"Field of View\\\").onChange(render);\\r\\n\\r\\n  //---------\\r\\n\\r\\nconst el = gui.domElement;\\r\\n\\r\\n\\r\\n['pointerdown','pointermove','pointerup','wheel']\\r\\n  .forEach(e =>\\r\\n    gui.domElement.addEventListener(e, ev => ev.stopPropagation())\\r\\n  );\\r\\n\\r\\n\\r\\nel.style.position = 'fixed';\\r\\nel.style.left = '20px';\\r\\nel.style.top = '20px';\\r\\n\\r\\nvar offsetX, offsetY;\\r\\n\\r\\nfunction onMouseDown(e) {\\r\\n  isDragging = true;\\r\\n  offsetX = e.clientX - el.offsetLeft;\\r\\n  offsetY = e.clientY - el.offsetTop;\\r\\n}\\r\\n\\r\\nfunction onMouseMove(e) {\\r\\n  if (!isDragging) return;\\r\\n  el.style.left = `${e.clientX - offsetX}px`;\\r\\n  el.style.top = `${e.clientY - offsetY}px`;\\r\\n}\\r\\n\\r\\nfunction onMouseUp() {\\r\\n  isDragging = false;\\r\\n}\\r\\n\\r\\nfunction enableDrag() {\\r\\n  el.addEventListener('mousedown', onMouseDown);\\r\\n  document.addEventListener('mousemove', onMouseMove);\\r\\n  document.addEventListener('mouseup', onMouseUp);\\r\\n}\\r\\n\\r\\nfunction disableDrag() {\\r\\n  el.removeEventListener('mousedown', onMouseDown);\\r\\n  document.removeEventListener('mousemove', onMouseMove);\\r\\n  document.removeEventListener('mouseup', onMouseUp);\\r\\n  isDragging = false;\\r\\n}\\r\\n\\r\\n\\r\\n//---------  \\r\\n\\r\\n  gui.add(transformationObj,'ui_drag').name(\\\"Prevent UI From Dragging\\\").onChange(value => {\\r\\n    if (value) {\\r\\n      disableDrag(); // prevent dragging\\r\\n    } else {\\r\\n      enableDrag();  // allow dragging\\r\\n    }\\r\\n  });\\r\\n\\r\\n  \\r\\n  const camera_ctrl = gui.addFolder(\\\"Camera Control\\\");\\r\\n  const pers_ctrl = gui.addFolder(\\\"Far and Near\\\")\\r\\n  const obj = gui.addFolder('Object Control');\\r\\n  const translate = obj.addFolder('Translate');\\r\\n  const rotate = obj.addFolder('Rotate');\\r\\n  const scale = obj.addFolder('Scale');\\r\\n  const r = 1000;\\r\\n\\r\\n  pers_ctrl.add(transformationObj,'near',0,2000).name(\\\"Near\\\").onChange(render);\\r\\n  pers_ctrl.add(transformationObj,'far',0,2000).name(\\\"Far\\\").onChange(render);\\r\\n  pers_ctrl.add(transformationObj,'isOrtho').name(\\\"Orthographic Projection\\\").onChange(render);\\r\\n  pers_ctrl.add(transformationObj,'orthoUnit',0,120).name(\\\"Orthographic Unit\\\").onChange(render);\\r\\n  \\r\\n  \\r\\n  \\r\\n  camera_ctrl.add(transformationObj.camera_position,'x',-r,r).name(\\\"cx\\\").onChange(render);\\r\\n  camera_ctrl.add(transformationObj.camera_position,'y',-r,r).name(\\\"cy\\\").onChange(render);\\r\\n  camera_ctrl.add(transformationObj.camera_position,'z',-r,r).name(\\\"cz\\\").onChange(render);\\r\\n\\r\\n  \\r\\n  translate.add(transformationObj.translate,'tx',-r,r).onChange(render);\\r\\n  translate.add(transformationObj.translate,'ty',-r,r).onChange(render);\\r\\n  translate.add(transformationObj.translate,'tz',-2000,2000).onChange(render);\\r\\n\\r\\n  rotate.add(transformationObj.rotate,'rx',0,360).onChange(render);\\r\\n  rotate.add(transformationObj.rotate,'ry',0,360).onChange(render);\\r\\n  rotate.add(transformationObj.rotate,'rz',0,360).onChange(render);\\r\\n  \\r\\n  scale.add(transformationObj.scale,'sx',.1,10).onChange(render);\\r\\n  scale.add(transformationObj.scale,'sy',.1,10).onChange(render);\\r\\n  scale.add(transformationObj.scale,'sz',.1,10).onChange(render);\\r\\n\\r\\n  gui.addColor(transformationObj,'colors').onChange(render);\\r\\n\\r\\n\\r\\n\\r\\n//------\\r\\n\\r\\n\\r\\n\\r\\n\\r\\nfunction drawScene(projectionMatrix, cameraMatrix, worldMatrix){\\r\\n\\r\\n  \\r\\n    gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);\\r\\n\\r\\n    const viewMatrix = m4.inverse(cameraMatrix);\\r\\n\\r\\n    var matrix = m4.multiply(projectionMatrix, viewMatrix);\\r\\n    matrix = m4.multiply(matrix, worldMatrix);\\r\\n\\r\\n    gl.useProgram(program);\\r\\n    gl.bindVertexArray(vao);\\r\\n    \\r\\n    gl.uniformMatrix4fv(matrixLocation,false, matrix);\\r\\n\\r\\n\\r\\n    var primitivie = gl.TRIANGLES;\\r\\n    var offset = 0;\\r\\n    var count = 16*6;\\r\\n    gl.drawArrays(primitivie,offset,count);\\r\\n\\r\\n}\\r\\n\\r\\nfunction drawCameraControl(projectionMatrix,cameraMatrix,cameraMatrix2,color){\\r\\n    const viewMatrix = m4.inverse(cameraMatrix2);\\r\\n\\r\\n    var matrix = m4.multiply(projectionMatrix, viewMatrix);\\r\\n    matrix = m4.multiply(matrix, cameraMatrix);\\r\\n\\r\\n    gl.useProgram(camera_ctrl_program);\\r\\n    gl.bindVertexArray(camera_vao.vao);\\r\\n\\r\\n    gl.uniform4f(camera_ctrl_colorAttributeLocation, color.r,color.g, color.b, color.a);\\r\\n    \\r\\n    gl.uniformMatrix4fv(camera_ctrl_matrixUniformLocation, false, matrix);\\r\\n  \\r\\n   \\r\\n    // Draw lines\\r\\n    gl.drawElements(\\r\\n      gl.LINES,\\r\\n      camera_vao.indexCount,\\r\\n      gl.UNSIGNED_SHORT,\\r\\n      0\\r\\n    );\\r\\n\\r\\n    gl.bindVertexArray(camera_vao.vao);\\r\\n    return matrix;\\r\\n}\\r\\n\\r\\nfunction drawPerspectiveControl(projectionMatrix1,projectionMatrix2, cameraMatrix1,cameraMatrix2){\\r\\n  const viewMatrix = m4.inverse(cameraMatrix2);\\r\\n\\r\\n    var matrix = m4.multiply(projectionMatrix2, viewMatrix);\\r\\n    matrix = m4.multiply(matrix, cameraMatrix1);\\r\\n    matrix = m4.multiply(matrix, m4.inverse(projectionMatrix1));\\r\\n    gl.bindVertexArray(perspective_vao.vao);\\r\\n    gl.uniformMatrix4fv(camera_ctrl_matrixUniformLocation, false, matrix); \\r\\n  \\r\\n   \\r\\n    // Draw lines\\r\\n    gl.drawElements(\\r\\n      gl.LINES,\\r\\n      perspective_vao.indexCount,\\r\\n      gl.UNSIGNED_SHORT,\\r\\n      0\\r\\n    );\\r\\n\\r\\n    gl.bindVertexArray(perspective_vao.vao);\\r\\n  \\r\\n}\\r\\n\\r\\nfunction render(){\\r\\n  \\r\\n    RenderFitToScreen(gl.canvas, window.devicePixelRatio);\\r\\n\\r\\n    gl.enable(gl.CULL_FACE);\\r\\n    gl.enable(gl.DEPTH_TEST);\\r\\n    gl.enable(gl.SCISSOR_TEST);\\r\\n\\r\\n    var effectiveWidth = gl.canvas.clientWidth / 2.0;\\r\\n    var aspect = effectiveWidth/gl.canvas.clientHeight;\\r\\n   \\r\\n\\r\\n\\r\\n    \\r\\n    const t = transformationObj.translate;\\r\\n    const r = transformationObj.rotate;\\r\\n    const s = transformationObj.scale;\\r\\n    const c = transformationObj.colors;\\r\\n    \\r\\n \\r\\n\\r\\n\\r\\n    var camera_object = transformationObj.camera_position;    \\r\\n\\r\\n\\r\\n\\r\\n    var projectionMatrix = transformationObj.isOrtho ?\\r\\n          m4.orthographic(\\r\\n            -transformationObj.orthoUnit * aspect,\\r\\n             transformationObj.orthoUnit * aspect,\\r\\n            -transformationObj.orthoUnit,\\r\\n             transformationObj.orthoUnit,\\r\\n              transformationObj.near, transformationObj.far\\r\\n          )\\r\\n         :m4.perspective(deg_to_rad(transformationObj.fov), aspect,  transformationObj.near, transformationObj.far);\\r\\n    var cameraPosition = [camera_object.x,camera_object.y,camera_object.z];\\r\\n    var target = [0, 0, 0];\\r\\n    var up = [0 , 1, 0];\\r\\n    var cameraMatrix = m4.lookAt(cameraPosition, target, up);\\r\\n    \\r\\n    //var worldMatrix = m4.translate(worldMatrix, -35, -75, -5);\\r\\n    //var worldMatrix = m4.yRotation(deg_to_rad(r.ry));\\r\\n    //worldMatrix = m4.xRotate(worldMatrix, deg_to_rad(r.rx));\\r\\n    // center the 'F' around its origin\\r\\n    var worldMatrix = m4.translation( t.tx,t.ty,t.tz);\\r\\n    worldMatrix = m4.xRotate(worldMatrix, deg_to_rad(r.rx));\\r\\n    worldMatrix = m4.yRotate(worldMatrix, deg_to_rad(r.ry));\\r\\n    worldMatrix = m4.zRotate(worldMatrix, deg_to_rad(r.rz));\\r\\n    worldMatrix = m4.scale(worldMatrix, s.sx,s.sy,s.sz);\\r\\n\\r\\n    var {width, height} = gl.canvas;\\r\\n    var leftWidth = width / 2 | 0; \\r\\n\\r\\n    gl.viewport(0,0,leftWidth, height);\\r\\n    gl.scissor(0, 0,leftWidth, height);\\r\\n    gl.clearColor(1,0.8,0.8,1);\\r\\n\\r\\n    drawScene(projectionMatrix, cameraMatrix, worldMatrix);\\r\\n\\r\\n    //right side\\r\\n\\r\\n\\r\\n    var rightWidth = width - leftWidth;\\r\\n    gl.viewport(leftWidth,0,rightWidth,height);\\r\\n    gl.scissor(leftWidth,0,rightWidth,height);\\r\\n    gl.clearColor(0.8, 0.8, 1, 1);\\r\\n    var projectionMatrix2 = m4.perspective(deg_to_rad(transformationObj.fov), aspect,zNear,zFar);\\r\\n    var cameraPosition2 = [-600, 400, -400];\\r\\n    var target2 = [0,0,0];\\r\\n    var cameraMatrix2 = m4.lookAt(cameraPosition2,target2,up)\\r\\n\\r\\n    drawScene(projectionMatrix2, cameraMatrix2, worldMatrix);\\r\\n\\r\\n\\r\\n   drawCameraControl(projectionMatrix2,cameraMatrix,cameraMatrix2,c);\\r\\n   drawPerspectiveControl(projectionMatrix,projectionMatrix2,cameraMatrix,cameraMatrix2);\\r\\n\\r\\n\\r\\n}\\r\\n\\r\\nrender();\\r\\n\\r\\n}\\r\\n\\r\\nmain();\",\n  \"html\": \"<canvas id=\\\"canvas\\\"></canvas>\\r\\n<title>Visualizing the Camera</title>\\r\\n<script src=\\\"https://cdn.jsdelivr.net/gh/engineer-work/WebGL-lib@f4fff51/shaders/shaderLoader.js\\\"></script>\\r\\n<script src=\\\"https://cdn.jsdelivr.net/gh/engineer-work/WebGL-lib@866810f/render/render_fit_to_screen.js\\\"></script>\\r\\n<script src=\\\"https://cdn.jsdelivr.net/gh/engineer-work/WebGL-lib@3ef60f3/geometry/english/3d/f_c.js\\\"></script>\\r\\n<script src=\\\"https://cdn.jsdelivr.net/gh/engineer-work/WebGL-lib@37ac783/transform/matrix/m4_v1.js\\\"></script>\\r\\n<script src=\\\"https://cdn.jsdelivr.net/npm/lil-gui@0.21\\\"></script>\\r\\n\",\n  \"css\": \" body { margin: 0 }\\r\\n\\r\\ncanvas {\\r\\n  width: 100vw;\\r\\n  height: 100vh;\\r\\n  display: block;\\r\\n}\",\n  \"internal_block_id\": \"ide-26298513-f753-4075-9a8c-40256d68240d\"\n}\n```",
      "createdAt": 1768974621317
    }
  ]
}
